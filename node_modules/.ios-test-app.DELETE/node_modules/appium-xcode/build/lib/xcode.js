'use strict';

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _appiumLogger = require('appium-logger');

var _appiumSupport = require('appium-support');

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _asyncbox = require('asyncbox');

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _plist = require('plist');

var _teen_process = require('teen_process');

var env = process.env;

var XCODE_SELECT_TIMEOUT = 3000;
var XCODE_SUBDIR = "/Contents/Developer";
var DEFAULT_NUMBER_OF_RETRIES = 3;

var log = (0, _appiumLogger.getLogger)('Xcode');

function hasExpectedSubDir(path) {
  return path.substring(path.length - XCODE_SUBDIR.length) === XCODE_SUBDIR;
}

function getPathFromSymlink(failMessage) {
  var symlinkPath, legacySymlinkPath, xcodePath, customPath, mesg, msg;
  return _regeneratorRuntime.async(function getPathFromSymlink$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        // Node's invocation of xcode-select sometimes flakes and returns an empty string.
        // Not clear why. As a workaround, Appium can reliably deduce the version in use by checking
        // the locations xcode-select uses to store the selected version's path. This should be 100%
        // reliable so long as the link locations remain the same. However, since we're relying on
        // hardcoded paths, this approach will break the next time Apple changes the symlink location.
        log.warn('Finding XcodePath by symlink because ' + failMessage);

        symlinkPath = "/var/db/xcode_select_link";
        legacySymlinkPath = "/usr/share/xcode-select/xcode_dir_link";
        xcodePath = null;

        if (!_appiumSupport.util.hasContent(env.DEVELOPER_DIR)) {
          context$1$0.next = 17;
          break;
        }

        customPath = hasExpectedSubDir(env.DEVELOPER_DIR) ? env.DEVELOPER_DIR : env.DEVELOPER_DIR + XCODE_SUBDIR;
        context$1$0.next = 8;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.exists(customPath));

      case 8:
        if (!context$1$0.sent) {
          context$1$0.next = 12;
          break;
        }

        xcodePath = customPath;
        context$1$0.next = 15;
        break;

      case 12:
        mesg = 'Could not find path to Xcode, environment variable ' + ('DEVELOPER_DIR set to: ' + env.DEVELOPER_DIR + ' ') + 'but no Xcode found';

        log.warn(mesg);
        throw new Error(mesg);

      case 15:
        context$1$0.next = 31;
        break;

      case 17:
        context$1$0.next = 19;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.exists(symlinkPath));

      case 19:
        if (!context$1$0.sent) {
          context$1$0.next = 25;
          break;
        }

        context$1$0.next = 22;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.readlink(symlinkPath));

      case 22:
        xcodePath = context$1$0.sent;
        context$1$0.next = 31;
        break;

      case 25:
        context$1$0.next = 27;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.exists(legacySymlinkPath));

      case 27:
        if (!context$1$0.sent) {
          context$1$0.next = 31;
          break;
        }

        context$1$0.next = 30;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.readlink(legacySymlinkPath));

      case 30:
        xcodePath = context$1$0.sent;

      case 31:
        if (!xcodePath) {
          context$1$0.next = 33;
          break;
        }

        return context$1$0.abrupt('return', xcodePath.replace(new RegExp("/$"), "").trim());

      case 33:
        msg = 'Could not find path to Xcode by symlinks located in ' + symlinkPath + ', or ' + legacySymlinkPath;

        log.warn(msg);
        throw new Error(msg);

      case 36:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

function getPathFromXcodeSelect() {
  var _ref, stdout, xcodeFolderPath, msg;

  return _regeneratorRuntime.async(function getPathFromXcodeSelect$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)('xcode-select', ['--print-path'], { timeout: XCODE_SELECT_TIMEOUT }));

      case 2:
        _ref = context$1$0.sent;
        stdout = _ref.stdout;
        xcodeFolderPath = stdout.replace(/\/$/, '').trim();

        if (_appiumSupport.util.hasContent(xcodeFolderPath)) {
          context$1$0.next = 7;
          break;
        }

        throw new Error("xcode-select returned an empty string");

      case 7:
        context$1$0.next = 9;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.exists(xcodeFolderPath));

      case 9:
        if (!context$1$0.sent) {
          context$1$0.next = 13;
          break;
        }

        return context$1$0.abrupt('return', xcodeFolderPath);

      case 13:
        msg = 'xcode-select could not find xcode. Path: ' + xcodeFolderPath + ' does not exist.';

        log.error(msg);
        throw new Error(msg);

      case 16:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

var getPath = _lodash2['default'].memoize(function () {

  // first we try using xcode-select to find the path
  // then we try using the symlinks that Apple has by default

  return getPathFromXcodeSelect()['catch'](getPathFromSymlink);
});

function getVersionWithoutRetry() {
  var xcodePath, plistPath, version, versionPattern, match;
  return _regeneratorRuntime.async(function getVersionWithoutRetry$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(getPath());

      case 2:
        xcodePath = context$1$0.sent;
        plistPath = _path2['default'].resolve(xcodePath, "..", "Info.plist");
        context$1$0.next = 6;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.exists(plistPath));

      case 6:
        if (context$1$0.sent) {
          context$1$0.next = 8;
          break;
        }

        throw new Error('Could not get Xcode version. ' + plistPath + ' does not exist on disk.');

      case 8:
        context$1$0.next = 10;
        return _regeneratorRuntime.awrap(_appiumSupport.plist.parsePlistFile(plistPath));

      case 10:
        version = context$1$0.sent;

        version = version.CFBundleShortVersionString;

        versionPattern = /\d\.\d\.*\d*/;
        match = version.match(versionPattern);

        if (!(match === null || !_appiumSupport.util.hasContent(match[0]))) {
          context$1$0.next = 16;
          break;
        }

        throw new Error('Could not parse Xcode version. xcodebuild output was: ' + version);

      case 16:
        return context$1$0.abrupt('return', match[0]);

      case 17:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

var getVersionMemoized = _lodash2['default'].memoize(function () {
  var retries = arguments.length <= 0 || arguments[0] === undefined ? DEFAULT_NUMBER_OF_RETRIES : arguments[0];

  return (0, _asyncbox.retry)(retries, getVersionWithoutRetry);
});

function getVersion() {
  var parse = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];
  var retries = arguments.length <= 1 || arguments[1] === undefined ? DEFAULT_NUMBER_OF_RETRIES : arguments[1];
  var version, match;
  return _regeneratorRuntime.async(function getVersion$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(getVersionMemoized(retries));

      case 2:
        version = context$1$0.sent;

        if (parse) {
          context$1$0.next = 5;
          break;
        }

        return context$1$0.abrupt('return', version);

      case 5:
        match = /^(\d+)\.(\d+)(\.(\d+))?$/.exec(version);
        return context$1$0.abrupt('return', {
          versionString: version,
          versionFloat: parseFloat(match[1] + '.' + match[2]),
          major: parseInt(match[1]),
          minor: parseInt(match[2]),
          patch: match[4] ? parseInt(match[4]) : undefined
        });

      case 7:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

function getAutomationTraceTemplatePathWithoutRetry() {
  var xcodePath, extensions, pathPrefix, pathSuffix, automationTraceTemplatePaths, msg;
  return _regeneratorRuntime.async(function getAutomationTraceTemplatePathWithoutRetry$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(getPath());

      case 2:
        xcodePath = context$1$0.sent;
        extensions = ['xrplugin', 'bundle'];
        pathPrefix = _path2['default'].resolve(xcodePath, "../Applications/Instruments.app/Contents/PlugIns");
        pathSuffix = "Contents/Resources/Automation.tracetemplate";
        automationTraceTemplatePaths = [_path2['default'].resolve(pathPrefix, "AutomationInstrument." + extensions[0], pathSuffix), _path2['default'].resolve(pathPrefix, "AutomationInstrument." + extensions[1], pathSuffix)];
        context$1$0.next = 9;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.exists(automationTraceTemplatePaths[0]));

      case 9:
        if (!context$1$0.sent) {
          context$1$0.next = 11;
          break;
        }

        return context$1$0.abrupt('return', automationTraceTemplatePaths[0]);

      case 11:
        context$1$0.next = 13;
        return _regeneratorRuntime.awrap(_appiumSupport.fs.exists(automationTraceTemplatePaths[1]));

      case 13:
        if (!context$1$0.sent) {
          context$1$0.next = 15;
          break;
        }

        return context$1$0.abrupt('return', automationTraceTemplatePaths[1]);

      case 15:
        msg = "Could not find Automation.tracetemplate in any of the following" + ('locations ' + automationTraceTemplatePaths.toString());

        log.error(msg);
        throw new Error(msg);

      case 18:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

var getAutomationTraceTemplatePath = _lodash2['default'].memoize(function () {
  var retries = arguments.length <= 0 || arguments[0] === undefined ? DEFAULT_NUMBER_OF_RETRIES : arguments[0];

  return (0, _asyncbox.retry)(retries, getAutomationTraceTemplatePathWithoutRetry);
});

function getMaxIOSSDKWithoutRetry() {
  var version, cmd, args, _ref2, stdout, sdkVersion, match;

  return _regeneratorRuntime.async(function getMaxIOSSDKWithoutRetry$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(getVersion());

      case 2:
        version = context$1$0.sent;

        if (!(version[0] === '4')) {
          context$1$0.next = 5;
          break;
        }

        return context$1$0.abrupt('return', '6.1');

      case 5:
        cmd = 'xcrun';
        args = ['--sdk', 'iphonesimulator', '--show-sdk-version'];
        context$1$0.next = 9;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)(cmd, args, { timeout: XCODE_SELECT_TIMEOUT }));

      case 9:
        _ref2 = context$1$0.sent;
        stdout = _ref2.stdout;
        sdkVersion = stdout.trim();
        match = /\d.\d/.exec(stdout);

        if (match) {
          context$1$0.next = 15;
          break;
        }

        throw new Error('xcrun returned a non-numeric iOS SDK version: ' + sdkVersion);

      case 15:
        return context$1$0.abrupt('return', sdkVersion);

      case 16:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

var getMaxIOSSDK = _lodash2['default'].memoize(function () {
  var retries = arguments.length <= 0 || arguments[0] === undefined ? DEFAULT_NUMBER_OF_RETRIES : arguments[0];

  return (0, _asyncbox.retry)(retries, getMaxIOSSDKWithoutRetry);
});

function getConnectedDevices() {
  var cmd, args, _ref3, stdout, plistContent, devicesFound, entriesToSearch, currentEntry, deviceInfo;

  return _regeneratorRuntime.async(function getConnectedDevices$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        cmd = '/usr/sbin/system_profiler';
        args = ['-xml', 'SPUSBDataType'];
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)(cmd, args, { timeout: XCODE_SELECT_TIMEOUT }));

      case 4:
        _ref3 = context$1$0.sent;
        stdout = _ref3.stdout;
        plistContent = (0, _plist.parse)(stdout);
        devicesFound = [];
        entriesToSearch = [plistContent[0]];

        while (entriesToSearch.length > 0) {
          currentEntry = entriesToSearch.pop();

          if (currentEntry instanceof Array) {
            entriesToSearch = entriesToSearch.concat(currentEntry);
          } else if (currentEntry._name && currentEntry._name.substring(0, 4) === "iPad" || currentEntry._name && currentEntry._name.substring(0, 6) === "iPhone") {
            deviceInfo = {
              name: currentEntry._name,
              udid: currentEntry.serial_num,
              productId: currentEntry.product_id,
              deviceVersion: currentEntry.bcd_device
            };

            devicesFound.push(deviceInfo);
          } else if (currentEntry._items) {
            entriesToSearch = entriesToSearch.concat(currentEntry._items);
          }
        }
        return context$1$0.abrupt('return', devicesFound);

      case 11:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

function getInstrumentsPathWithoutRetry() {
  var cmd, args, _ref4, stdout, instrumentsPath;

  return _regeneratorRuntime.async(function getInstrumentsPathWithoutRetry$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        cmd = 'xcrun';
        args = ['-find', 'instruments'];
        context$1$0.next = 4;
        return _regeneratorRuntime.awrap((0, _teen_process.exec)(cmd, args, { timeout: XCODE_SELECT_TIMEOUT }));

      case 4:
        _ref4 = context$1$0.sent;
        stdout = _ref4.stdout;

        if (!stdout) {
          stdout = "";
        }

        instrumentsPath = stdout.trim();

        if (instrumentsPath) {
          context$1$0.next = 10;
          break;
        }

        throw new Error('Could not find path to instruments binary using "' + cmd + '"');

      case 10:
        return context$1$0.abrupt('return', instrumentsPath);

      case 11:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

var getInstrumentsPath = _lodash2['default'].memoize(function () {
  var retries = arguments.length <= 0 || arguments[0] === undefined ? DEFAULT_NUMBER_OF_RETRIES : arguments[0];

  return (0, _asyncbox.retry)(retries, getInstrumentsPathWithoutRetry);
});

function clearInternalCache() {

  // memoized functions
  var memoized = [getPath, getVersionMemoized, getAutomationTraceTemplatePath, getMaxIOSSDK, getInstrumentsPath];

  memoized.forEach(function (f) {
    if (f.cache) {
      f.cache = new _lodash2['default'].memoize.Cache();
    }
  });
}

exports['default'] = { getPath: getPath, getVersion: getVersion, getAutomationTraceTemplatePath: getAutomationTraceTemplatePath, getMaxIOSSDK: getMaxIOSSDK,
  getAutomationTraceTemplatePathWithoutRetry: getAutomationTraceTemplatePathWithoutRetry, getMaxIOSSDKWithoutRetry: getMaxIOSSDKWithoutRetry,
  getConnectedDevices: getConnectedDevices, clearInternalCache: clearInternalCache, getInstrumentsPath: getInstrumentsPath };
module.exports = exports['default'];
//  Xcode < 5.x

// xcode-select allows users to override its settings with the DEVELOPER_DIR env var,
// so check that first

// We should only get here is we failed to capture xcode-select's stdout and our
// other checks failed. Either Apple has moved the symlink to a new location or the user
// is not using the default install. 99.999% chance it's the latter, so issue a warning
// should we ever hit the edge case.

// trim and remove trailing slash

// we want to read the CFBundleShortVersionString from Xcode's plist.
// It should be in /[root]/XCode.app/Contents/

// need to use string#match here; previous code used regexp#exec, which does not return null

// match should be an array, either of
//     [ '7.0', '7', '0', undefined, undefined, index: 0, input: '7.0' ]
//     [ '7.0.1', '7', '0', '.1', '1', index: 0, input: '7.0.1' ]

// for ios 8 and up, the file extension for AutiomationInstrument changed.
// rather than waste time getting the iOSSDKVersion, just get both paths and see which one exists
//# sourceMappingURL=data:application/json;base64,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RSxrQkFBa0IsRUFBRSw4QkFBOEIsRUFDM0QsWUFBWSxFQUFFLGtCQUFrQixDQUFDLENBQUM7O0FBRXBELFVBQVEsQ0FBQyxPQUFPLENBQUMsVUFBQyxDQUFDLEVBQUs7QUFDdEIsUUFBSSxDQUFDLENBQUMsS0FBSyxFQUFFO0FBQ1gsT0FBQyxDQUFDLEtBQUssR0FBRyxJQUFJLG9CQUFFLE9BQU8sQ0FBQyxLQUFLLEVBQUUsQ0FBQztLQUNqQztHQUNGLENBQUMsQ0FBQztDQUNKOztxQkFFYyxFQUFFLE9BQU8sRUFBUCxPQUFPLEVBQUUsVUFBVSxFQUFWLFVBQVUsRUFBRSw4QkFBOEIsRUFBOUIsOEJBQThCLEVBQUUsWUFBWSxFQUFaLFlBQVk7QUFDekUsNENBQTBDLEVBQTFDLDBDQUEwQyxFQUFFLHdCQUF3QixFQUF4Qix3QkFBd0I7QUFDcEUscUJBQW1CLEVBQW5CLG1CQUFtQixFQUFFLGtCQUFrQixFQUFsQixrQkFBa0IsRUFBRSxrQkFBa0IsRUFBbEIsa0JBQWtCLEVBQUUiLCJmaWxlIjoibGliL3hjb2RlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0TG9nZ2VyIH0gZnJvbSAnYXBwaXVtLWxvZ2dlcic7XG5pbXBvcnQgeyB1dGlsLCBmcywgcGxpc3QgfSBmcm9tICdhcHBpdW0tc3VwcG9ydCc7XG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCB7IHJldHJ5IH0gZnJvbSAnYXN5bmNib3gnO1xuaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IHBhcnNlIGFzIHBhcnNlUGxpc3REYXRhIH0gZnJvbSAncGxpc3QnO1xuaW1wb3J0IHsgZXhlYyB9IGZyb20gJ3RlZW5fcHJvY2Vzcyc7XG5cbmNvbnN0IGVudiA9IHByb2Nlc3MuZW52O1xuXG5jb25zdCBYQ09ERV9TRUxFQ1RfVElNRU9VVCA9IDMwMDA7XG5jb25zdCBYQ09ERV9TVUJESVIgPSBcIi9Db250ZW50cy9EZXZlbG9wZXJcIjtcbmNvbnN0IERFRkFVTFRfTlVNQkVSX09GX1JFVFJJRVMgPSAzO1xuXG5jb25zdCBsb2cgPSBnZXRMb2dnZXIoJ1hjb2RlJyk7XG5cblxuZnVuY3Rpb24gaGFzRXhwZWN0ZWRTdWJEaXIgKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGguc3Vic3RyaW5nKHBhdGgubGVuZ3RoIC0gWENPREVfU1VCRElSLmxlbmd0aCkgPT09IFhDT0RFX1NVQkRJUjtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZ2V0UGF0aEZyb21TeW1saW5rIChmYWlsTWVzc2FnZSkge1xuICAvLyBOb2RlJ3MgaW52b2NhdGlvbiBvZiB4Y29kZS1zZWxlY3Qgc29tZXRpbWVzIGZsYWtlcyBhbmQgcmV0dXJucyBhbiBlbXB0eSBzdHJpbmcuXG4gIC8vIE5vdCBjbGVhciB3aHkuIEFzIGEgd29ya2Fyb3VuZCwgQXBwaXVtIGNhbiByZWxpYWJseSBkZWR1Y2UgdGhlIHZlcnNpb24gaW4gdXNlIGJ5IGNoZWNraW5nXG4gIC8vIHRoZSBsb2NhdGlvbnMgeGNvZGUtc2VsZWN0IHVzZXMgdG8gc3RvcmUgdGhlIHNlbGVjdGVkIHZlcnNpb24ncyBwYXRoLiBUaGlzIHNob3VsZCBiZSAxMDAlXG4gIC8vIHJlbGlhYmxlIHNvIGxvbmcgYXMgdGhlIGxpbmsgbG9jYXRpb25zIHJlbWFpbiB0aGUgc2FtZS4gSG93ZXZlciwgc2luY2Ugd2UncmUgcmVseWluZyBvblxuICAvLyBoYXJkY29kZWQgcGF0aHMsIHRoaXMgYXBwcm9hY2ggd2lsbCBicmVhayB0aGUgbmV4dCB0aW1lIEFwcGxlIGNoYW5nZXMgdGhlIHN5bWxpbmsgbG9jYXRpb24uXG4gIGxvZy53YXJuKGBGaW5kaW5nIFhjb2RlUGF0aCBieSBzeW1saW5rIGJlY2F1c2UgJHtmYWlsTWVzc2FnZX1gKTtcblxuICBjb25zdCBzeW1saW5rUGF0aCA9IFwiL3Zhci9kYi94Y29kZV9zZWxlY3RfbGlua1wiO1xuICBjb25zdCBsZWdhY3lTeW1saW5rUGF0aCA9IFwiL3Vzci9zaGFyZS94Y29kZS1zZWxlY3QveGNvZGVfZGlyX2xpbmtcIjsgLy8gIFhjb2RlIDwgNS54XG4gIGxldCB4Y29kZVBhdGggPSBudWxsO1xuXG4gIC8vIHhjb2RlLXNlbGVjdCBhbGxvd3MgdXNlcnMgdG8gb3ZlcnJpZGUgaXRzIHNldHRpbmdzIHdpdGggdGhlIERFVkVMT1BFUl9ESVIgZW52IHZhcixcbiAgLy8gc28gY2hlY2sgdGhhdCBmaXJzdFxuICBpZiAodXRpbC5oYXNDb250ZW50KGVudi5ERVZFTE9QRVJfRElSKSkge1xuICAgIGNvbnN0IGN1c3RvbVBhdGggPSBoYXNFeHBlY3RlZFN1YkRpcihlbnYuREVWRUxPUEVSX0RJUikgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnYuREVWRUxPUEVSX0RJUiAgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnYuREVWRUxPUEVSX0RJUiArIFhDT0RFX1NVQkRJUjtcblxuICAgIGlmIChhd2FpdCBmcy5leGlzdHMoY3VzdG9tUGF0aCkpIHtcbiAgICAgIHhjb2RlUGF0aCA9IGN1c3RvbVBhdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBtZXNnID0gYENvdWxkIG5vdCBmaW5kIHBhdGggdG8gWGNvZGUsIGVudmlyb25tZW50IHZhcmlhYmxlIGAgK1xuICAgICAgICAgICAgICAgICBgREVWRUxPUEVSX0RJUiBzZXQgdG86ICR7ZW52LkRFVkVMT1BFUl9ESVJ9IGAgK1xuICAgICAgICAgICAgICAgICBgYnV0IG5vIFhjb2RlIGZvdW5kYDtcbiAgICAgIGxvZy53YXJuKG1lc2cpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc2cpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChhd2FpdCBmcy5leGlzdHMoc3ltbGlua1BhdGgpKSB7XG4gICAgeGNvZGVQYXRoID0gYXdhaXQgZnMucmVhZGxpbmsoc3ltbGlua1BhdGgpO1xuICB9IGVsc2UgaWYgKGF3YWl0IGZzLmV4aXN0cyhsZWdhY3lTeW1saW5rUGF0aCkpIHtcbiAgICB4Y29kZVBhdGggPSBhd2FpdCBmcy5yZWFkbGluayhsZWdhY3lTeW1saW5rUGF0aCk7XG4gIH1cblxuICBpZiAoeGNvZGVQYXRoKSB7XG4gICAgcmV0dXJuIHhjb2RlUGF0aC5yZXBsYWNlKG5ldyBSZWdFeHAoXCIvJFwiKSwgXCJcIikudHJpbSgpO1xuICB9XG5cbiAgLy8gV2Ugc2hvdWxkIG9ubHkgZ2V0IGhlcmUgaXMgd2UgZmFpbGVkIHRvIGNhcHR1cmUgeGNvZGUtc2VsZWN0J3Mgc3Rkb3V0IGFuZCBvdXJcbiAgLy8gb3RoZXIgY2hlY2tzIGZhaWxlZC4gRWl0aGVyIEFwcGxlIGhhcyBtb3ZlZCB0aGUgc3ltbGluayB0byBhIG5ldyBsb2NhdGlvbiBvciB0aGUgdXNlclxuICAvLyBpcyBub3QgdXNpbmcgdGhlIGRlZmF1bHQgaW5zdGFsbC4gOTkuOTk5JSBjaGFuY2UgaXQncyB0aGUgbGF0dGVyLCBzbyBpc3N1ZSBhIHdhcm5pbmdcbiAgLy8gc2hvdWxkIHdlIGV2ZXIgaGl0IHRoZSBlZGdlIGNhc2UuXG4gIGxldCBtc2cgPSBgQ291bGQgbm90IGZpbmQgcGF0aCB0byBYY29kZSBieSBzeW1saW5rcyBsb2NhdGVkIGluICR7c3ltbGlua1BhdGh9LCBvciAke2xlZ2FjeVN5bWxpbmtQYXRofWA7XG4gIGxvZy53YXJuKG1zZyk7XG4gIHRocm93IG5ldyBFcnJvcihtc2cpO1xuXG59XG5cbmFzeW5jIGZ1bmN0aW9uIGdldFBhdGhGcm9tWGNvZGVTZWxlY3QgKCkge1xuICBsZXQge3N0ZG91dH0gPSBhd2FpdCBleGVjKCd4Y29kZS1zZWxlY3QnLCBbJy0tcHJpbnQtcGF0aCddLCB7dGltZW91dDogWENPREVfU0VMRUNUX1RJTUVPVVR9KTtcblxuICAvLyB0cmltIGFuZCByZW1vdmUgdHJhaWxpbmcgc2xhc2hcbiAgY29uc3QgeGNvZGVGb2xkZXJQYXRoID0gc3Rkb3V0LnJlcGxhY2UoL1xcLyQvLCAnJykudHJpbSgpO1xuXG4gIGlmICghdXRpbC5oYXNDb250ZW50KHhjb2RlRm9sZGVyUGF0aCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ4Y29kZS1zZWxlY3QgcmV0dXJuZWQgYW4gZW1wdHkgc3RyaW5nXCIpO1xuICB9XG5cbiAgaWYgKGF3YWl0IGZzLmV4aXN0cyh4Y29kZUZvbGRlclBhdGgpKSB7XG4gICAgcmV0dXJuIHhjb2RlRm9sZGVyUGF0aDtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBtc2cgPSBgeGNvZGUtc2VsZWN0IGNvdWxkIG5vdCBmaW5kIHhjb2RlLiBQYXRoOiAke3hjb2RlRm9sZGVyUGF0aH0gZG9lcyBub3QgZXhpc3QuYDtcbiAgICBsb2cuZXJyb3IobXNnKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgfVxufVxuXG5jb25zdCBnZXRQYXRoID0gXy5tZW1vaXplKGZ1bmN0aW9uICgpIHtcblxuICAvLyBmaXJzdCB3ZSB0cnkgdXNpbmcgeGNvZGUtc2VsZWN0IHRvIGZpbmQgdGhlIHBhdGhcbiAgLy8gdGhlbiB3ZSB0cnkgdXNpbmcgdGhlIHN5bWxpbmtzIHRoYXQgQXBwbGUgaGFzIGJ5IGRlZmF1bHRcblxuICByZXR1cm4gZ2V0UGF0aEZyb21YY29kZVNlbGVjdCgpLmNhdGNoKGdldFBhdGhGcm9tU3ltbGluayk7XG59KTtcblxuXG5cbmFzeW5jIGZ1bmN0aW9uIGdldFZlcnNpb25XaXRob3V0UmV0cnkgKCkge1xuICBsZXQgeGNvZGVQYXRoID0gYXdhaXQgZ2V0UGF0aCgpO1xuXG4gIC8vIHdlIHdhbnQgdG8gcmVhZCB0aGUgQ0ZCdW5kbGVTaG9ydFZlcnNpb25TdHJpbmcgZnJvbSBYY29kZSdzIHBsaXN0LlxuICAvLyBJdCBzaG91bGQgYmUgaW4gL1tyb290XS9YQ29kZS5hcHAvQ29udGVudHMvXG4gIGNvbnN0IHBsaXN0UGF0aCA9IHBhdGgucmVzb2x2ZSh4Y29kZVBhdGgsIFwiLi5cIiwgXCJJbmZvLnBsaXN0XCIpO1xuXG4gIGlmICghYXdhaXQgZnMuZXhpc3RzKHBsaXN0UGF0aCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBnZXQgWGNvZGUgdmVyc2lvbi4gJHtwbGlzdFBhdGh9IGRvZXMgbm90IGV4aXN0IG9uIGRpc2suYCk7XG4gIH1cblxuICBsZXQgdmVyc2lvbiA9IGF3YWl0IHBsaXN0LnBhcnNlUGxpc3RGaWxlKHBsaXN0UGF0aCk7XG4gIHZlcnNpb24gPSB2ZXJzaW9uLkNGQnVuZGxlU2hvcnRWZXJzaW9uU3RyaW5nO1xuXG4gIGxldCB2ZXJzaW9uUGF0dGVybiA9IC9cXGRcXC5cXGRcXC4qXFxkKi87XG4gIC8vIG5lZWQgdG8gdXNlIHN0cmluZyNtYXRjaCBoZXJlOyBwcmV2aW91cyBjb2RlIHVzZWQgcmVnZXhwI2V4ZWMsIHdoaWNoIGRvZXMgbm90IHJldHVybiBudWxsXG4gIGxldCBtYXRjaCA9IHZlcnNpb24ubWF0Y2godmVyc2lvblBhdHRlcm4pO1xuICBpZiAobWF0Y2ggPT09IG51bGwgfHwgIXV0aWwuaGFzQ29udGVudChtYXRjaFswXSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBwYXJzZSBYY29kZSB2ZXJzaW9uLiB4Y29kZWJ1aWxkIG91dHB1dCB3YXM6ICR7dmVyc2lvbn1gKTtcbiAgfVxuXG4gIHJldHVybiBtYXRjaFswXTtcbn1cblxuY29uc3QgZ2V0VmVyc2lvbk1lbW9pemVkID0gXy5tZW1vaXplKFxuICBmdW5jdGlvbiAocmV0cmllcyA9IERFRkFVTFRfTlVNQkVSX09GX1JFVFJJRVMpIHtcbiAgICByZXR1cm4gcmV0cnkocmV0cmllcywgZ2V0VmVyc2lvbldpdGhvdXRSZXRyeSk7XG4gIH1cbik7XG5cbmFzeW5jIGZ1bmN0aW9uIGdldFZlcnNpb24gKHBhcnNlID0gZmFsc2UsIHJldHJpZXMgPSBERUZBVUxUX05VTUJFUl9PRl9SRVRSSUVTKSB7XG4gIGxldCB2ZXJzaW9uID0gYXdhaXQgZ2V0VmVyc2lvbk1lbW9pemVkKHJldHJpZXMpO1xuICBpZiAoIXBhcnNlKSB7XG4gICAgcmV0dXJuIHZlcnNpb247XG4gIH1cbiAgbGV0IG1hdGNoID0gL14oXFxkKylcXC4oXFxkKykoXFwuKFxcZCspKT8kLy5leGVjKHZlcnNpb24pO1xuICAvLyBtYXRjaCBzaG91bGQgYmUgYW4gYXJyYXksIGVpdGhlciBvZlxuICAvLyAgICAgWyAnNy4wJywgJzcnLCAnMCcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBpbmRleDogMCwgaW5wdXQ6ICc3LjAnIF1cbiAgLy8gICAgIFsgJzcuMC4xJywgJzcnLCAnMCcsICcuMScsICcxJywgaW5kZXg6IDAsIGlucHV0OiAnNy4wLjEnIF1cbiAgcmV0dXJuIHtcbiAgICB2ZXJzaW9uU3RyaW5nOiB2ZXJzaW9uLFxuICAgIHZlcnNpb25GbG9hdDogcGFyc2VGbG9hdChgJHttYXRjaFsxXX0uJHttYXRjaFsyXX1gKSxcbiAgICBtYWpvcjogcGFyc2VJbnQobWF0Y2hbMV0pLFxuICAgIG1pbm9yOiBwYXJzZUludChtYXRjaFsyXSksXG4gICAgcGF0Y2g6IG1hdGNoWzRdID8gcGFyc2VJbnQobWF0Y2hbNF0pIDogdW5kZWZpbmVkXG4gIH07XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGdldEF1dG9tYXRpb25UcmFjZVRlbXBsYXRlUGF0aFdpdGhvdXRSZXRyeSAoKSB7XG5cbiAgY29uc3QgeGNvZGVQYXRoID0gYXdhaXQgZ2V0UGF0aCgpO1xuXG4gIC8vIGZvciBpb3MgOCBhbmQgdXAsIHRoZSBmaWxlIGV4dGVuc2lvbiBmb3IgQXV0aW9tYXRpb25JbnN0cnVtZW50IGNoYW5nZWQuXG4gIC8vIHJhdGhlciB0aGFuIHdhc3RlIHRpbWUgZ2V0dGluZyB0aGUgaU9TU0RLVmVyc2lvbiwganVzdCBnZXQgYm90aCBwYXRocyBhbmQgc2VlIHdoaWNoIG9uZSBleGlzdHNcbiAgY29uc3QgZXh0ZW5zaW9ucyA9IFsneHJwbHVnaW4nLCAnYnVuZGxlJ107XG4gIGNvbnN0IHBhdGhQcmVmaXggPSBwYXRoLnJlc29sdmUoeGNvZGVQYXRoLCBcIi4uL0FwcGxpY2F0aW9ucy9JbnN0cnVtZW50cy5hcHAvQ29udGVudHMvUGx1Z0luc1wiKTtcbiAgY29uc3QgcGF0aFN1ZmZpeCA9IFwiQ29udGVudHMvUmVzb3VyY2VzL0F1dG9tYXRpb24udHJhY2V0ZW1wbGF0ZVwiO1xuICBsZXQgYXV0b21hdGlvblRyYWNlVGVtcGxhdGVQYXRocyA9IFtcbiAgICBwYXRoLnJlc29sdmUocGF0aFByZWZpeCwgXCJBdXRvbWF0aW9uSW5zdHJ1bWVudC5cIiArIGV4dGVuc2lvbnNbMF0sIHBhdGhTdWZmaXgpLFxuICAgIHBhdGgucmVzb2x2ZShwYXRoUHJlZml4LCBcIkF1dG9tYXRpb25JbnN0cnVtZW50LlwiICsgZXh0ZW5zaW9uc1sxXSwgcGF0aFN1ZmZpeClcbiAgXTtcblxuICBpZiAoYXdhaXQgZnMuZXhpc3RzKGF1dG9tYXRpb25UcmFjZVRlbXBsYXRlUGF0aHNbMF0pKSB7XG4gICAgcmV0dXJuIGF1dG9tYXRpb25UcmFjZVRlbXBsYXRlUGF0aHNbMF07XG4gIH1cblxuICBpZiAoYXdhaXQgZnMuZXhpc3RzKGF1dG9tYXRpb25UcmFjZVRlbXBsYXRlUGF0aHNbMV0pKSB7XG4gICAgcmV0dXJuIGF1dG9tYXRpb25UcmFjZVRlbXBsYXRlUGF0aHNbMV07XG4gIH1cblxuICBjb25zdCBtc2cgPSBcIkNvdWxkIG5vdCBmaW5kIEF1dG9tYXRpb24udHJhY2V0ZW1wbGF0ZSBpbiBhbnkgb2YgdGhlIGZvbGxvd2luZ1wiICtcbiAgICAgICAgICAgICAgYGxvY2F0aW9ucyAke2F1dG9tYXRpb25UcmFjZVRlbXBsYXRlUGF0aHMudG9TdHJpbmcoKX1gO1xuICBsb2cuZXJyb3IobXNnKTtcbiAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG5cbn1cblxuY29uc3QgZ2V0QXV0b21hdGlvblRyYWNlVGVtcGxhdGVQYXRoID0gXy5tZW1vaXplKFxuICBmdW5jdGlvbiAocmV0cmllcyA9IERFRkFVTFRfTlVNQkVSX09GX1JFVFJJRVMpIHtcbiAgICByZXR1cm4gcmV0cnkocmV0cmllcywgZ2V0QXV0b21hdGlvblRyYWNlVGVtcGxhdGVQYXRoV2l0aG91dFJldHJ5KTtcbiAgfVxuKTtcblxuYXN5bmMgZnVuY3Rpb24gZ2V0TWF4SU9TU0RLV2l0aG91dFJldHJ5ICgpIHtcblxuICBjb25zdCB2ZXJzaW9uID0gYXdhaXQgZ2V0VmVyc2lvbigpO1xuICBpZiAodmVyc2lvblswXSA9PT0gJzQnKSB7XG4gICAgcmV0dXJuICc2LjEnO1xuICB9XG5cbiAgY29uc3QgY21kID0gYHhjcnVuYDtcbiAgY29uc3QgYXJncyA9IFsnLS1zZGsnLCAgJ2lwaG9uZXNpbXVsYXRvcicsICAnLS1zaG93LXNkay12ZXJzaW9uJ107XG4gIGNvbnN0IHtzdGRvdXR9ID0gYXdhaXQgZXhlYyhjbWQsIGFyZ3MsIHt0aW1lb3V0OiBYQ09ERV9TRUxFQ1RfVElNRU9VVH0pO1xuXG4gIGNvbnN0IHNka1ZlcnNpb24gPSBzdGRvdXQudHJpbSgpO1xuICBjb25zdCBtYXRjaCA9IC9cXGQuXFxkLy5leGVjKHN0ZG91dCk7XG5cbiAgaWYgKCFtYXRjaCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgeGNydW4gcmV0dXJuZWQgYSBub24tbnVtZXJpYyBpT1MgU0RLIHZlcnNpb246ICR7c2RrVmVyc2lvbn1gKTtcbiAgfVxuXG4gIHJldHVybiBzZGtWZXJzaW9uO1xufVxuXG5jb25zdCBnZXRNYXhJT1NTREsgPSBfLm1lbW9pemUoXG4gIGZ1bmN0aW9uIChyZXRyaWVzID0gREVGQVVMVF9OVU1CRVJfT0ZfUkVUUklFUykge1xuICAgIHJldHVybiByZXRyeShyZXRyaWVzLCBnZXRNYXhJT1NTREtXaXRob3V0UmV0cnkpO1xuICB9XG4pO1xuXG5hc3luYyBmdW5jdGlvbiBnZXRDb25uZWN0ZWREZXZpY2VzICgpIHtcblxuICBjb25zdCBjbWQgPSAnL3Vzci9zYmluL3N5c3RlbV9wcm9maWxlcic7XG4gIGNvbnN0IGFyZ3MgPSBbJy14bWwnLCAnU1BVU0JEYXRhVHlwZSddO1xuICBsZXQge3N0ZG91dH0gPSBhd2FpdCBleGVjKGNtZCwgYXJncywge3RpbWVvdXQ6IFhDT0RFX1NFTEVDVF9USU1FT1VUfSk7XG4gIGxldCBwbGlzdENvbnRlbnQgPSBwYXJzZVBsaXN0RGF0YShzdGRvdXQpO1xuXG4gIGxldCBkZXZpY2VzRm91bmQgPSBbXTtcbiAgbGV0IGVudHJpZXNUb1NlYXJjaCA9IFtwbGlzdENvbnRlbnRbMF1dO1xuICB3aGlsZSAoZW50cmllc1RvU2VhcmNoLmxlbmd0aCA+IDApIHtcbiAgICBsZXQgY3VycmVudEVudHJ5ID0gZW50cmllc1RvU2VhcmNoLnBvcCgpO1xuICAgIGlmIChjdXJyZW50RW50cnkgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgZW50cmllc1RvU2VhcmNoID0gZW50cmllc1RvU2VhcmNoLmNvbmNhdChjdXJyZW50RW50cnkpO1xuICAgIH0gZWxzZSBpZiAoKGN1cnJlbnRFbnRyeS5fbmFtZSAmJlxuICAgICAgICAgICAgICAgIGN1cnJlbnRFbnRyeS5fbmFtZS5zdWJzdHJpbmcoMCwgNCkgPT09IFwiaVBhZFwiKSB8fFxuICAgICAgICAgICAgICAgKGN1cnJlbnRFbnRyeS5fbmFtZSAmJlxuICAgICAgICAgICAgICAgIGN1cnJlbnRFbnRyeS5fbmFtZS5zdWJzdHJpbmcoMCwgNikgPT09IFwiaVBob25lXCIpKSB7XG4gICAgICBsZXQgZGV2aWNlSW5mbyA9IHtcbiAgICAgICAgbmFtZTogY3VycmVudEVudHJ5Ll9uYW1lLFxuICAgICAgICB1ZGlkOiBjdXJyZW50RW50cnkuc2VyaWFsX251bSxcbiAgICAgICAgcHJvZHVjdElkOiBjdXJyZW50RW50cnkucHJvZHVjdF9pZCxcbiAgICAgICAgZGV2aWNlVmVyc2lvbjogY3VycmVudEVudHJ5LmJjZF9kZXZpY2VcbiAgICAgIH07XG4gICAgICBkZXZpY2VzRm91bmQucHVzaChkZXZpY2VJbmZvKTtcbiAgICB9IGVsc2UgaWYgKGN1cnJlbnRFbnRyeS5faXRlbXMpIHtcbiAgICAgIGVudHJpZXNUb1NlYXJjaCA9IGVudHJpZXNUb1NlYXJjaC5jb25jYXQoY3VycmVudEVudHJ5Ll9pdGVtcyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBkZXZpY2VzRm91bmQ7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGdldEluc3RydW1lbnRzUGF0aFdpdGhvdXRSZXRyeSAoKSB7XG5cbiAgY29uc3QgY21kID0gJ3hjcnVuJztcbiAgY29uc3QgYXJncyA9IFsnLWZpbmQnLCAnaW5zdHJ1bWVudHMnXTtcbiAgbGV0IHtzdGRvdXR9ID0gYXdhaXQgZXhlYyhjbWQsIGFyZ3MsIHt0aW1lb3V0OiBYQ09ERV9TRUxFQ1RfVElNRU9VVH0pO1xuXG4gIGlmICghc3Rkb3V0KSB7XG4gICAgc3Rkb3V0ID0gXCJcIjtcbiAgfVxuXG4gIGxldCBpbnN0cnVtZW50c1BhdGggPSBzdGRvdXQudHJpbSgpO1xuXG4gIGlmICghaW5zdHJ1bWVudHNQYXRoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZmluZCBwYXRoIHRvIGluc3RydW1lbnRzIGJpbmFyeSB1c2luZyBcIiR7Y21kfVwiYCk7XG4gIH1cblxuICByZXR1cm4gaW5zdHJ1bWVudHNQYXRoO1xufVxuXG5jb25zdCBnZXRJbnN0cnVtZW50c1BhdGggPSBfLm1lbW9pemUoXG4gIGZ1bmN0aW9uIChyZXRyaWVzID0gREVGQVVMVF9OVU1CRVJfT0ZfUkVUUklFUykge1xuICAgIHJldHVybiByZXRyeShyZXRyaWVzLCBnZXRJbnN0cnVtZW50c1BhdGhXaXRob3V0UmV0cnkpO1xuICB9XG4pO1xuXG5mdW5jdGlvbiBjbGVhckludGVybmFsQ2FjaGUgKCkge1xuXG4gIC8vIG1lbW9pemVkIGZ1bmN0aW9uc1xuICBjb25zdCBtZW1vaXplZCA9IFtnZXRQYXRoLCBnZXRWZXJzaW9uTWVtb2l6ZWQsIGdldEF1dG9tYXRpb25UcmFjZVRlbXBsYXRlUGF0aCxcbiAgICAgICAgICAgICAgICAgICAgZ2V0TWF4SU9TU0RLLCBnZXRJbnN0cnVtZW50c1BhdGhdO1xuXG4gIG1lbW9pemVkLmZvckVhY2goKGYpID0+IHtcbiAgICBpZiAoZi5jYWNoZSkge1xuICAgICAgZi5jYWNoZSA9IG5ldyBfLm1lbW9pemUuQ2FjaGUoKTtcbiAgICB9XG4gIH0pO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7IGdldFBhdGgsIGdldFZlcnNpb24sIGdldEF1dG9tYXRpb25UcmFjZVRlbXBsYXRlUGF0aCwgZ2V0TWF4SU9TU0RLLFxuICAgICAgICAgZ2V0QXV0b21hdGlvblRyYWNlVGVtcGxhdGVQYXRoV2l0aG91dFJldHJ5LCBnZXRNYXhJT1NTREtXaXRob3V0UmV0cnksXG4gICAgICAgICBnZXRDb25uZWN0ZWREZXZpY2VzLCBjbGVhckludGVybmFsQ2FjaGUsIGdldEluc3RydW1lbnRzUGF0aCB9O1xuIl19