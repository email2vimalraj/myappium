require('source-map-support').install();

'use strict';

var _slicedToArray = require('babel-runtime/helpers/sliced-to-array')['default'];

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

var _this = this;

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _chai = require('chai');

var _chai2 = _interopRequireDefault(_chai);

var _chaiAsPromised = require('chai-as-promised');

var _chaiAsPromised2 = _interopRequireDefault(_chaiAsPromised);

var _rimraf = require('rimraf');

var _rimraf2 = _interopRequireDefault(_rimraf);

var _q = require('q');

var _q2 = _interopRequireDefault(_q);

require('mochawait');

var _libInstall = require('../lib/install');

var _libChromedriver = require('../lib/chromedriver');

var _libChromedriver2 = _interopRequireDefault(_libChromedriver);

var stat = _q2['default'].denodeify(_fs2['default'].stat);

var should = _chai2['default'].should();
_chai2['default'].use(_chaiAsPromised2['default']);

describe('install scripts', function () {

  function assertNoPreviousDirs() {
    var err;
    return _regeneratorRuntime.async(function assertNoPreviousDirs$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          err = undefined;
          context$2$0.prev = 1;
          context$2$0.next = 4;
          return _regeneratorRuntime.awrap(stat(_libInstall.CD_BASE_DIR));

        case 4:
          context$2$0.next = 9;
          break;

        case 6:
          context$2$0.prev = 6;
          context$2$0.t0 = context$2$0['catch'](1);

          err = context$2$0.t0;

        case 9:
          should.exist(err);
          err.code.should.eql("ENOENT");

        case 11:
        case 'end':
          return context$2$0.stop();
      }
    }, null, this, [[1, 6]]);
  }

  beforeEach(function callee$1$0() {
    return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          context$2$0.next = 2;
          return _regeneratorRuntime.awrap(_q2['default'].denodeify(_rimraf2['default'])(_libInstall.CD_BASE_DIR));

        case 2:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this);
  });

  it('should install for this platform', function callee$1$0() {
    var cdPath, cdStat, cd;
    return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          context$2$0.next = 2;
          return _regeneratorRuntime.awrap(assertNoPreviousDirs());

        case 2:
          context$2$0.next = 4;
          return _regeneratorRuntime.awrap((0, _libInstall.install)());

        case 4:
          context$2$0.next = 6;
          return _regeneratorRuntime.awrap((0, _libInstall.getChromedriverBinaryPath)());

        case 6:
          cdPath = context$2$0.sent;
          context$2$0.next = 9;
          return _regeneratorRuntime.awrap(stat(cdPath));

        case 9:
          cdStat = context$2$0.sent;

          cdStat.size.should.be.above(5000000);
          cdPath.should.contain((0, _libInstall.getCurPlatform)());
          cd = new _libChromedriver2['default']();
          context$2$0.next = 15;
          return _regeneratorRuntime.awrap(cd.initChromedriverPath());

        case 15:
          cd.chromedriver.should.equal(cdPath);

        case 16:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this);
  });

  it('should install for all platforms', function callee$1$0() {
    var plats, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _step$value, platform, arch, cdPath, cdStat;

    return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          context$2$0.next = 2;
          return _regeneratorRuntime.awrap(assertNoPreviousDirs());

        case 2:
          context$2$0.next = 4;
          return _regeneratorRuntime.awrap((0, _libInstall.installAll)());

        case 4:
          plats = [['linux', '32'], ['linux', '64'], ['win', '32'], ['mac', '32']];
          _iteratorNormalCompletion = true;
          _didIteratorError = false;
          _iteratorError = undefined;
          context$2$0.prev = 8;
          _iterator = _getIterator(plats);

        case 10:
          if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
            context$2$0.next = 26;
            break;
          }

          _step$value = _slicedToArray(_step.value, 2);
          platform = _step$value[0];
          arch = _step$value[1];
          context$2$0.next = 16;
          return _regeneratorRuntime.awrap((0, _libInstall.getChromedriverBinaryPath)(platform, arch));

        case 16:
          cdPath = context$2$0.sent;
          context$2$0.next = 19;
          return _regeneratorRuntime.awrap(stat(cdPath));

        case 19:
          cdStat = context$2$0.sent;

          cdStat.size.should.be.above(5000000);
          cdPath.should.contain(platform);
          if (platform === "linux") {
            cdPath.should.contain(arch);
          } else {
            cdPath.should.not.contain(arch);
          }

        case 23:
          _iteratorNormalCompletion = true;
          context$2$0.next = 10;
          break;

        case 26:
          context$2$0.next = 32;
          break;

        case 28:
          context$2$0.prev = 28;
          context$2$0.t0 = context$2$0['catch'](8);
          _didIteratorError = true;
          _iteratorError = context$2$0.t0;

        case 32:
          context$2$0.prev = 32;
          context$2$0.prev = 33;

          if (!_iteratorNormalCompletion && _iterator['return']) {
            _iterator['return']();
          }

        case 35:
          context$2$0.prev = 35;

          if (!_didIteratorError) {
            context$2$0.next = 38;
            break;
          }

          throw _iteratorError;

        case 38:
          return context$2$0.finish(35);

        case 39:
          return context$2$0.finish(32);

        case 40:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this, [[8, 28, 32, 40], [33,, 35, 39]]);
  });

  it('should throw an error in chromedriver if nothing is installed', function callee$1$0() {
    var cd, err;
    return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          context$2$0.next = 2;
          return _regeneratorRuntime.awrap(assertNoPreviousDirs());

        case 2:
          cd = new _libChromedriver2['default']();
          err = undefined;
          context$2$0.prev = 4;
          context$2$0.next = 7;
          return _regeneratorRuntime.awrap(cd.initChromedriverPath());

        case 7:
          context$2$0.next = 12;
          break;

        case 9:
          context$2$0.prev = 9;
          context$2$0.t0 = context$2$0['catch'](4);

          err = context$2$0.t0;

        case 12:
          should.exist(err);
          err.message.should.contain("path");

        case 14:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this, [[4, 9]]);
  });
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInRlc3QvaW5zdGFsbC1zcGVjcy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztrQkFFZSxJQUFJOzs7O29CQUNGLE1BQU07Ozs7OEJBQ0ksa0JBQWtCOzs7O3NCQUMxQixRQUFROzs7O2lCQUNiLEdBQUc7Ozs7UUFDVixXQUFXOzswQkFFYSxnQkFBZ0I7OytCQUN0QixxQkFBcUI7Ozs7QUFFOUMsSUFBTSxJQUFJLEdBQUcsZUFBRSxTQUFTLENBQUMsZ0JBQUcsSUFBSSxDQUFDLENBQUM7O0FBRWxDLElBQUksTUFBTSxHQUFHLGtCQUFLLE1BQU0sRUFBRSxDQUFDO0FBQzNCLGtCQUFLLEdBQUcsNkJBQWdCLENBQUM7O0FBRXpCLFFBQVEsQ0FBQyxpQkFBaUIsRUFBRSxZQUFNOztBQUVoQyxXQUFlLG9CQUFvQjtRQUM3QixHQUFHOzs7O0FBQUgsYUFBRzs7OzJDQUVDLElBQUksYUFkUCxXQUFXLENBY1M7Ozs7Ozs7Ozs7QUFFdkIsYUFBRyxpQkFBSSxDQUFDOzs7QUFFVixnQkFBTSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUNsQixhQUFHLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUM7Ozs7Ozs7R0FDL0I7O0FBRUQsWUFBVSxDQUFDOzs7OzsyQ0FDSCxlQUFFLFNBQVMscUJBQVEsYUF2QnBCLFdBQVcsQ0F1QnNCOzs7Ozs7O0dBQ3ZDLENBQUMsQ0FBQzs7QUFFSCxJQUFFLENBQUMsa0NBQWtDLEVBQUU7UUFHakMsTUFBTSxFQUNOLE1BQU0sRUFHTixFQUFFOzs7OzsyQ0FOQSxvQkFBb0IsRUFBRTs7OzsyQ0FDdEIsZ0JBNUJZLE9BQU8sR0E0QlY7Ozs7MkNBQ0ksZ0JBN0JvQix5QkFBeUIsR0E2QmxCOzs7QUFBMUMsZ0JBQU07OzJDQUNTLElBQUksQ0FBQyxNQUFNLENBQUM7OztBQUEzQixnQkFBTTs7QUFDVixnQkFBTSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQztBQUNyQyxnQkFBTSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsZ0JBL0JqQixjQUFjLEdBK0JtQixDQUFDLENBQUM7QUFDcEMsWUFBRSxHQUFHLGtDQUFrQjs7MkNBQ3JCLEVBQUUsQ0FBQyxvQkFBb0IsRUFBRTs7O0FBQy9CLFlBQUUsQ0FBQyxZQUFZLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQzs7Ozs7OztHQUN0QyxDQUFDLENBQUM7O0FBRUgsSUFBRSxDQUFDLGtDQUFrQyxFQUFFO1FBRy9CLEtBQUssK0ZBTUQsUUFBUSxFQUFFLElBQUksRUFDbEIsTUFBTSxFQUNOLE1BQU07Ozs7OzsyQ0FWTixvQkFBb0IsRUFBRTs7OzsyQ0FDdEIsZ0JBeENxQixVQUFVLEdBd0NuQjs7O0FBQ1osZUFBSyxHQUFHLENBQ1osQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLEVBQ2YsQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLEVBQ2YsQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLEVBQ2IsQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLENBQ2Q7Ozs7O21DQUM0QixLQUFLOzs7Ozs7Ozs7QUFBeEIsa0JBQVE7QUFBRSxjQUFJOzsyQ0FDSCxnQkFoRGtCLHlCQUF5QixFQWdEakIsUUFBUSxFQUFFLElBQUksQ0FBQzs7O0FBQXhELGdCQUFNOzsyQ0FDUyxJQUFJLENBQUMsTUFBTSxDQUFDOzs7QUFBM0IsZ0JBQU07O0FBQ1YsZ0JBQU0sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUM7QUFDckMsZ0JBQU0sQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0FBQ2hDLGNBQUksUUFBUSxLQUFLLE9BQU8sRUFBRTtBQUN4QixrQkFBTSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7V0FDN0IsTUFBTTtBQUNMLGtCQUFNLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7V0FDakM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FFSixDQUFDLENBQUM7O0FBRUgsSUFBRSxDQUFDLCtEQUErRCxFQUFFO1FBRTlELEVBQUUsRUFDRixHQUFHOzs7OzsyQ0FGRCxvQkFBb0IsRUFBRTs7O0FBQ3hCLFlBQUUsR0FBRyxrQ0FBa0I7QUFDdkIsYUFBRzs7OzJDQUVDLEVBQUUsQ0FBQyxvQkFBb0IsRUFBRTs7Ozs7Ozs7OztBQUUvQixhQUFHLGlCQUFJLENBQUM7OztBQUVWLGdCQUFNLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQ2xCLGFBQUcsQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQzs7Ozs7OztHQUNwQyxDQUFDLENBQUM7Q0FDSixDQUFDLENBQUMiLCJmaWxlIjoidGVzdC9pbnN0YWxsLXNwZWNzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gdHJhbnNwaWxlOm1vY2hhXG5cbmltcG9ydCBmcyBmcm9tICdmcyc7XG5pbXBvcnQgY2hhaSBmcm9tICdjaGFpJztcbmltcG9ydCBjaGFpQXNQcm9taXNlZCBmcm9tICdjaGFpLWFzLXByb21pc2VkJztcbmltcG9ydCByaW1yYWYgZnJvbSAncmltcmFmJztcbmltcG9ydCBRIGZyb20gJ3EnO1xuaW1wb3J0ICdtb2NoYXdhaXQnO1xuaW1wb3J0IHsgQ0RfQkFTRV9ESVIsIGluc3RhbGwsIGluc3RhbGxBbGwsIGdldENocm9tZWRyaXZlckJpbmFyeVBhdGgsXG4gICAgICAgICBnZXRDdXJQbGF0Zm9ybSB9IGZyb20gJy4uL2xpYi9pbnN0YWxsJztcbmltcG9ydCBDaHJvbWVkcml2ZXIgZnJvbSAnLi4vbGliL2Nocm9tZWRyaXZlcic7XG5cbmNvbnN0IHN0YXQgPSBRLmRlbm9kZWlmeShmcy5zdGF0KTtcblxubGV0IHNob3VsZCA9IGNoYWkuc2hvdWxkKCk7XG5jaGFpLnVzZShjaGFpQXNQcm9taXNlZCk7XG5cbmRlc2NyaWJlKCdpbnN0YWxsIHNjcmlwdHMnLCAoKSA9PiB7XG5cbiAgYXN5bmMgZnVuY3Rpb24gYXNzZXJ0Tm9QcmV2aW91c0RpcnMgKCkge1xuICAgIGxldCBlcnI7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHN0YXQoQ0RfQkFTRV9ESVIpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGVyciA9IGU7XG4gICAgfVxuICAgIHNob3VsZC5leGlzdChlcnIpO1xuICAgIGVyci5jb2RlLnNob3VsZC5lcWwoXCJFTk9FTlRcIik7XG4gIH1cblxuICBiZWZvcmVFYWNoKGFzeW5jICgpID0+IHtcbiAgICBhd2FpdCBRLmRlbm9kZWlmeShyaW1yYWYpKENEX0JBU0VfRElSKTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCBpbnN0YWxsIGZvciB0aGlzIHBsYXRmb3JtJywgYXN5bmMgKCkgPT4ge1xuICAgIGF3YWl0IGFzc2VydE5vUHJldmlvdXNEaXJzKCk7XG4gICAgYXdhaXQgaW5zdGFsbCgpO1xuICAgIGxldCBjZFBhdGggPSBhd2FpdCBnZXRDaHJvbWVkcml2ZXJCaW5hcnlQYXRoKCk7XG4gICAgbGV0IGNkU3RhdCA9IGF3YWl0IHN0YXQoY2RQYXRoKTtcbiAgICBjZFN0YXQuc2l6ZS5zaG91bGQuYmUuYWJvdmUoNTAwMDAwMCk7XG4gICAgY2RQYXRoLnNob3VsZC5jb250YWluKGdldEN1clBsYXRmb3JtKCkpO1xuICAgIGxldCBjZCA9IG5ldyBDaHJvbWVkcml2ZXIoKTtcbiAgICBhd2FpdCBjZC5pbml0Q2hyb21lZHJpdmVyUGF0aCgpO1xuICAgIGNkLmNocm9tZWRyaXZlci5zaG91bGQuZXF1YWwoY2RQYXRoKTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCBpbnN0YWxsIGZvciBhbGwgcGxhdGZvcm1zJywgYXN5bmMgKCkgPT4ge1xuICAgIGF3YWl0IGFzc2VydE5vUHJldmlvdXNEaXJzKCk7XG4gICAgYXdhaXQgaW5zdGFsbEFsbCgpO1xuICAgIGNvbnN0IHBsYXRzID0gW1xuICAgICAgWydsaW51eCcsICczMiddLFxuICAgICAgWydsaW51eCcsICc2NCddLFxuICAgICAgWyd3aW4nLCAnMzInXSxcbiAgICAgIFsnbWFjJywgJzMyJ11cbiAgICBdO1xuICAgIGZvciAobGV0IFtwbGF0Zm9ybSwgYXJjaF0gb2YgcGxhdHMpIHtcbiAgICAgIGxldCBjZFBhdGggPSBhd2FpdCBnZXRDaHJvbWVkcml2ZXJCaW5hcnlQYXRoKHBsYXRmb3JtLCBhcmNoKTtcbiAgICAgIGxldCBjZFN0YXQgPSBhd2FpdCBzdGF0KGNkUGF0aCk7XG4gICAgICBjZFN0YXQuc2l6ZS5zaG91bGQuYmUuYWJvdmUoNTAwMDAwMCk7XG4gICAgICBjZFBhdGguc2hvdWxkLmNvbnRhaW4ocGxhdGZvcm0pO1xuICAgICAgaWYgKHBsYXRmb3JtID09PSBcImxpbnV4XCIpIHtcbiAgICAgICAgY2RQYXRoLnNob3VsZC5jb250YWluKGFyY2gpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2RQYXRoLnNob3VsZC5ub3QuY29udGFpbihhcmNoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgdGhyb3cgYW4gZXJyb3IgaW4gY2hyb21lZHJpdmVyIGlmIG5vdGhpbmcgaXMgaW5zdGFsbGVkJywgYXN5bmMgKCkgPT4ge1xuICAgIGF3YWl0IGFzc2VydE5vUHJldmlvdXNEaXJzKCk7XG4gICAgbGV0IGNkID0gbmV3IENocm9tZWRyaXZlcigpO1xuICAgIGxldCBlcnI7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGNkLmluaXRDaHJvbWVkcml2ZXJQYXRoKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXJyID0gZTtcbiAgICB9XG4gICAgc2hvdWxkLmV4aXN0KGVycik7XG4gICAgZXJyLm1lc3NhZ2Uuc2hvdWxkLmNvbnRhaW4oXCJwYXRoXCIpO1xuICB9KTtcbn0pO1xuIl19