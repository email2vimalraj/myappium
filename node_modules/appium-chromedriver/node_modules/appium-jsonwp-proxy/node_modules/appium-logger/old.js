androidController.parseTouch = function (gestures, multi, cb) {
  if (multi && _.last(gestures).action === 'release') {
    gestures.pop();
  }

  var needsPoint = function (action) {
    return _.contains(['press', 'moveTo', 'tap', 'longPress'], action);
  };

  var touchStateObjects = [];
  async.eachSeries(gestures, function (gesture, done) {
    var options = gesture.options;
    if (needsPoint(gesture.action)) {
      options.offset = false;
      var elementId = gesture.options.element;
      if (elementId) {
        this.getLocation(elementId, function (err, res) {
          if (err) return done(err); // short circuit and quit

          var pos = { x: res.value.x, y: res.value.y };
          this.getSize(elementId, function (err, res) {
            if (err) return done(err);
            var size = {w: res.value.width, h: res.value.height};

            if (gesture.options.x || gesture.options.y) {
              options.x = pos.x + (gesture.options.x || 0);
              options.y = pos.y + (gesture.options.y || 0);
            } else {
              options.x =  pos.x + (size.w / 2);
              options.y = pos.y + (size.h / 2);
            }

            var touchStateObject = {
              action: gesture.action,
              options: options,
              timeOffset: 0.005,
            };
            touchStateObjects.push(touchStateObject);
            done();
          });
        }.bind(this));
      } else {
        // expects absolute coordinates, so we need to save these as offsets
        // and then translate when everything is done
        options.offset = true;
        options.x = (gesture.options.x || 0);
        options.y = (gesture.options.y || 0);

        touchStateObject = {
          action: gesture.action,
          options: options,
          timeOffset: 0.005,
        };
        touchStateObjects.push(touchStateObject);
        done();
      }
    } else {
      var offset = 0.005;
      if (gesture.action === 'wait') {
        options = gesture.options;
        offset = (parseInt(gesture.options.ms) / 1000);
      }
      var touchStateObject = {
        action: gesture.action,
        options: options,
        timeOffset: offset,
      };
      touchStateObjects.push(touchStateObject);
      done();
    }
  }.bind(this), function (err) {
    if (err) return cb(err);

    // we need to change the time (which is now an offset)
    // and the position (which may be an offset)
    var prevPos = null,
        time = 0;
    _.each(touchStateObjects, function (state) {
      if (typeof state.options.x === 'undefined' && typeof state.options.x === 'undefined') {
        // this happens with wait
        state.options.x = prevPos.x;
        state.options.y = prevPos.y;
      }
      if (state.options.offset && prevPos) {
        // the current position is an offset
        state.options.x += prevPos.x;
        state.options.y += prevPos.y;
      }
      delete state.options.offset;
      prevPos = state.options;

      if (multi) {
        var timeOffset = state.timeOffset;
        time += timeOffset;
        state.time = helpers.truncateDecimals(time, 3);

        // multi gestures require 'touch' rather than 'options'
        state.touch = state.options;
        delete state.options;
      }

      delete state.timeOffset;
    });

    cb(null, touchStateObjects);
  });
};
