'use strict';

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

helpers.parseTouch = function callee$0$0(gestures, multi) {
  var touchStateObjects, prevPos, time, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, state, timeOffset;

  return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
    var _this = this;

    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        // because multi-touch releases at the end by default
        if (multi && _.last(gestures).action === 'release') {
          gestures.pop();
        }

        context$1$0.next = 3;
        return _regeneratorRuntime.awrap(asyncmap(gestures, function callee$1$0(gesture) {
          var options, elementId, pos, size, touchStateObject, offset;
          return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
            while (1) switch (context$2$0.prev = context$2$0.next) {
              case 0:
                options = gesture.options;

                if (!_.contains(['press', 'moveTo', 'tap', 'longPress'], gesture.action)) {
                  context$2$0.next = 23;
                  break;
                }

                options.offset = false;
                elementId = gesture.options.element;

                if (!elementId) {
                  context$2$0.next = 16;
                  break;
                }

                context$2$0.next = 7;
                return _regeneratorRuntime.awrap(this.getLocationInView(elementId));

              case 7:
                pos = context$2$0.sent;
                context$2$0.next = 10;
                return _regeneratorRuntime.awrap(this.getSize(elementId));

              case 10:
                size = context$2$0.sent;

                if (gesture.options.x || gesture.options.y) {
                  options.x = pos.x + (gesture.options.x || 0);
                  options.y = pos.y + (gesture.options.y || 0);
                } else {
                  options.x = pos.x + size.width / 2;
                  options.y = pos.y + size.height / 2;
                }
                touchStateObject = {
                  action: gesture.action,
                  options: options,
                  timeOffset: 0.005
                };
                return context$2$0.abrupt('return', touchStateObject);

              case 16:
                // expects absolute coordinates, so we need to save these as offsets
                // and then translate when everything is done
                options.offset = true;
                options.x = gesture.options.x || 0;
                options.y = gesture.options.y || 0;

                touchStateObject = {
                  action: gesture.action,
                  options: options,
                  timeOffset: 0.005
                };
                return context$2$0.abrupt('return', touchStateObject);

              case 21:
                context$2$0.next = 27;
                break;

              case 23:
                offset = 0.005;

                if (gesture.action === 'wait') {
                  options = gesture.options;
                  offset = parseInt(gesture.options.ms) / 1000;
                }
                touchStateObject = {
                  action: gesture.action,
                  options: options,
                  timeOffset: offset
                };
                return context$2$0.abrupt('return', touchStateObject);

              case 27:
              case 'end':
                return context$2$0.stop();
            }
          }, null, _this);
        }, false));

      case 3:
        touchStateObjects = context$1$0.sent;
        prevPos = null, time = 0;
        _iteratorNormalCompletion = true;
        _didIteratorError = false;
        _iteratorError = undefined;
        context$1$0.prev = 8;

        for (_iterator = _getIterator(touchStateObjects); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          state = _step.value;

          if (_.isUndefined(state.options.x) && _.isUndefined(state.options.y)) {
            // this happens with wait
            state.options.x = prevPos.x;
            state.options.y = prevPos.y;
          }
          if (state.options.offset && prevPos) {
            // the current position is an offset
            state.options.x += prevPos.x;
            state.options.y += prevPos.y;
          }
          delete state.options.offset;
          prevPos = state.options;

          if (multi) {
            timeOffset = state.timeOffset;

            time += timeOffset;
            state.time = androidHelpers.truncateDecimals(time, 3);

            // multi gestures require 'touch' rather than 'options'
            state.touch = state.options;
            delete state.options;
          }
          delete state.timeOffset;
        }
        context$1$0.next = 16;
        break;

      case 12:
        context$1$0.prev = 12;
        context$1$0.t0 = context$1$0['catch'](8);
        _didIteratorError = true;
        _iteratorError = context$1$0.t0;

      case 16:
        context$1$0.prev = 16;
        context$1$0.prev = 17;

        if (!_iteratorNormalCompletion && _iterator['return']) {
          _iterator['return']();
        }

      case 19:
        context$1$0.prev = 19;

        if (!_didIteratorError) {
          context$1$0.next = 22;
          break;
        }

        throw _iteratorError;

      case 22:
        return context$1$0.finish(19);

      case 23:
        return context$1$0.finish(16);

      case 24:
        return context$1$0.abrupt('return', touchStateObjects);

      case 25:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this, [[8, 12, 16, 24], [17,, 19, 23]]);
};

// we need to change the time (which is now an offset)
// and the position (which may be an offset)
//# sourceMappingURL=data:application/json;base64,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LENBQUMsT0FBTyxDQUFDO0FBQzVCLG1CQUFPLEtBQUssQ0FBQyxPQUFPLENBQUM7V0FDdEI7QUFDRCxpQkFBTyxLQUFLLENBQUMsVUFBVSxDQUFDO1NBQ3pCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs0Q0FDTSxpQkFBaUI7Ozs7Ozs7Q0FDekIsQ0FBQyIsImZpbGUiOiJuZXcuanMiLCJzb3VyY2VzQ29udGVudCI6WyJoZWxwZXJzLnBhcnNlVG91Y2ggPSBhc3luYyBmdW5jdGlvbiAoZ2VzdHVyZXMsIG11bHRpKSB7XG4gIC8vIGJlY2F1c2UgbXVsdGktdG91Y2ggcmVsZWFzZXMgYXQgdGhlIGVuZCBieSBkZWZhdWx0XG4gIGlmIChtdWx0aSAmJiBfLmxhc3QoZ2VzdHVyZXMpLmFjdGlvbiA9PT0gJ3JlbGVhc2UnKSB7XG4gICAgZ2VzdHVyZXMucG9wKCk7XG4gIH1cblxuICBsZXQgdG91Y2hTdGF0ZU9iamVjdHMgPSBhd2FpdCBhc3luY21hcChnZXN0dXJlcywgYXN5bmMgKGdlc3R1cmUpID0+IHtcbiAgICBsZXQgb3B0aW9ucyA9IGdlc3R1cmUub3B0aW9ucztcbiAgICBpZiAoXy5jb250YWlucyhbJ3ByZXNzJywgJ21vdmVUbycsICd0YXAnLCAnbG9uZ1ByZXNzJ10sIGdlc3R1cmUuYWN0aW9uKSkge1xuICAgICAgb3B0aW9ucy5vZmZzZXQgPSBmYWxzZTtcbiAgICAgIGxldCBlbGVtZW50SWQgPSBnZXN0dXJlLm9wdGlvbnMuZWxlbWVudDtcbiAgICAgIGlmIChlbGVtZW50SWQpIHtcbiAgICAgICAgbGV0IHBvcyA9IGF3YWl0IHRoaXMuZ2V0TG9jYXRpb25JblZpZXcoZWxlbWVudElkKTtcbiAgICAgICAgbGV0IHNpemUgPSBhd2FpdCB0aGlzLmdldFNpemUoZWxlbWVudElkKTtcbiAgICAgICAgaWYgKGdlc3R1cmUub3B0aW9ucy54IHx8IGdlc3R1cmUub3B0aW9ucy55KSB7XG4gICAgICAgICAgb3B0aW9ucy54ID0gcG9zLnggKyAoZ2VzdHVyZS5vcHRpb25zLnggfHwgMCk7XG4gICAgICAgICAgb3B0aW9ucy55ID0gcG9zLnkgKyAoZ2VzdHVyZS5vcHRpb25zLnkgfHwgMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3B0aW9ucy54ID0gIHBvcy54ICsgKHNpemUud2lkdGggLyAyKTtcbiAgICAgICAgICBvcHRpb25zLnkgPSBwb3MueSArIChzaXplLmhlaWdodCAvIDIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0b3VjaFN0YXRlT2JqZWN0ID0ge1xuICAgICAgICAgIGFjdGlvbjogZ2VzdHVyZS5hY3Rpb24sXG4gICAgICAgICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICAgICAgICB0aW1lT2Zmc2V0OiAwLjAwNSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRvdWNoU3RhdGVPYmplY3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBleHBlY3RzIGFic29sdXRlIGNvb3JkaW5hdGVzLCBzbyB3ZSBuZWVkIHRvIHNhdmUgdGhlc2UgYXMgb2Zmc2V0c1xuICAgICAgICAvLyBhbmQgdGhlbiB0cmFuc2xhdGUgd2hlbiBldmVyeXRoaW5nIGlzIGRvbmVcbiAgICAgICAgb3B0aW9ucy5vZmZzZXQgPSB0cnVlO1xuICAgICAgICBvcHRpb25zLnggPSAoZ2VzdHVyZS5vcHRpb25zLnggfHwgMCk7XG4gICAgICAgIG9wdGlvbnMueSA9IChnZXN0dXJlLm9wdGlvbnMueSB8fCAwKTtcblxuICAgICAgICBsZXQgdG91Y2hTdGF0ZU9iamVjdCA9IHtcbiAgICAgICAgICBhY3Rpb246IGdlc3R1cmUuYWN0aW9uLFxuICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICAgICAgdGltZU9mZnNldDogMC4wMDUsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0b3VjaFN0YXRlT2JqZWN0O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgb2Zmc2V0ID0gMC4wMDU7XG4gICAgICBpZiAoZ2VzdHVyZS5hY3Rpb24gPT09ICd3YWl0Jykge1xuICAgICAgICBvcHRpb25zID0gZ2VzdHVyZS5vcHRpb25zO1xuICAgICAgICBvZmZzZXQgPSAocGFyc2VJbnQoZ2VzdHVyZS5vcHRpb25zLm1zKSAvIDEwMDApO1xuICAgICAgfVxuICAgICAgbGV0IHRvdWNoU3RhdGVPYmplY3QgPSB7XG4gICAgICAgIGFjdGlvbjogZ2VzdHVyZS5hY3Rpb24sXG4gICAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICAgIHRpbWVPZmZzZXQ6IG9mZnNldCxcbiAgICAgIH07XG4gICAgICByZXR1cm4gdG91Y2hTdGF0ZU9iamVjdDtcbiAgICB9XG4gIH0sIGZhbHNlKTtcbiAgLy8gd2UgbmVlZCB0byBjaGFuZ2UgdGhlIHRpbWUgKHdoaWNoIGlzIG5vdyBhbiBvZmZzZXQpXG4gIC8vIGFuZCB0aGUgcG9zaXRpb24gKHdoaWNoIG1heSBiZSBhbiBvZmZzZXQpXG4gIGxldCBwcmV2UG9zID0gbnVsbCxcbiAgICAgIHRpbWUgPSAwO1xuICBmb3IgKGxldCBzdGF0ZSBvZiB0b3VjaFN0YXRlT2JqZWN0cykge1xuICAgIGlmIChfLmlzVW5kZWZpbmVkKHN0YXRlLm9wdGlvbnMueCkgJiYgXy5pc1VuZGVmaW5lZChzdGF0ZS5vcHRpb25zLnkpKSB7XG4gICAgICAvLyB0aGlzIGhhcHBlbnMgd2l0aCB3YWl0XG4gICAgICBzdGF0ZS5vcHRpb25zLnggPSBwcmV2UG9zLng7XG4gICAgICBzdGF0ZS5vcHRpb25zLnkgPSBwcmV2UG9zLnk7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5vcHRpb25zLm9mZnNldCAmJiBwcmV2UG9zKSB7XG4gICAgICAvLyB0aGUgY3VycmVudCBwb3NpdGlvbiBpcyBhbiBvZmZzZXRcbiAgICAgIHN0YXRlLm9wdGlvbnMueCArPSBwcmV2UG9zLng7XG4gICAgICBzdGF0ZS5vcHRpb25zLnkgKz0gcHJldlBvcy55O1xuICAgIH1cbiAgICBkZWxldGUgc3RhdGUub3B0aW9ucy5vZmZzZXQ7XG4gICAgcHJldlBvcyA9IHN0YXRlLm9wdGlvbnM7XG5cbiAgICBpZiAobXVsdGkpIHtcbiAgICAgIHZhciB0aW1lT2Zmc2V0ID0gc3RhdGUudGltZU9mZnNldDtcbiAgICAgIHRpbWUgKz0gdGltZU9mZnNldDtcbiAgICAgIHN0YXRlLnRpbWUgPSBhbmRyb2lkSGVscGVycy50cnVuY2F0ZURlY2ltYWxzKHRpbWUsIDMpO1xuXG4gICAgICAvLyBtdWx0aSBnZXN0dXJlcyByZXF1aXJlICd0b3VjaCcgcmF0aGVyIHRoYW4gJ29wdGlvbnMnXG4gICAgICBzdGF0ZS50b3VjaCA9IHN0YXRlLm9wdGlvbnM7XG4gICAgICBkZWxldGUgc3RhdGUub3B0aW9ucztcbiAgICB9XG4gICAgZGVsZXRlIHN0YXRlLnRpbWVPZmZzZXQ7XG4gIH1cbiAgcmV0dXJuIHRvdWNoU3RhdGVPYmplY3RzO1xufTtcbiJdfQ==