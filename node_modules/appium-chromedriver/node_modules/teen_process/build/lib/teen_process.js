'use strict';

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _get = require('babel-runtime/helpers/get')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _Object$defineProperty = require('babel-runtime/core-js/object/define-property')['default'];

var _Object$assign = require('babel-runtime/core-js/object/assign')['default'];

var _Promise = require('babel-runtime/core-js/promise')['default'];

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

_Object$defineProperty(exports, '__esModule', {
  value: true
});

var _child_process = require('child_process');

var _shellQuote = require('shell-quote');

var _events = require('events');

var _events2 = _interopRequireDefault(_events);

var _through = require('through');

var _through2 = _interopRequireDefault(_through);

var EventEmitter = _events2['default'].EventEmitter;

function exec(cmd) {
  var args = arguments[1] === undefined ? [] : arguments[1];
  var opts = arguments[2] === undefined ? {} : arguments[2];

  // get a quoted representation of the command for error strings
  var rep = _shellQuote.quote([cmd].concat(args));

  // extend default options; we're basically re-implementing exec's options
  // for use here with spawn under the hood
  opts = _Object$assign({
    timeout: null,
    encoding: 'utf8',
    killSignal: 'SIGTERM',
    cwd: undefined,
    env: process.env,
    ignoreOutput: false
  }, opts);

  // this is an async function, so return a promise
  return new _Promise(function (resolve, reject) {
    // spawn the child process with options; we don't currently expose any of
    // the other 'spawn' options through the API
    var proc = _child_process.spawn(cmd, args, { cwd: opts.cwd, env: opts.env });
    var stdout = '',
        stderr = '',
        timer = null;

    // if the process errors out, reject the promise
    proc.on('error', function (err) {
      reject(new Error('Command \'' + rep + '\' errored out: ' + err.stack));
    });

    // keep track of stdout/stderr if we haven't said not to
    if (!opts.ignoreOutput) {
      proc.stdout.on('data', function (data) {
        stdout += data;
      });
      proc.stderr.on('data', function (data) {
        stderr += data;
      });
    }

    // if the process ends, either resolve or reject the promise based on the
    // exit code of the process. either way, attach stdout, stderr, and code.
    // Also clean up the timer if it exists
    proc.on('close', function (code) {
      if (timer) {
        clearTimeout(timer);
      }
      stdout = stdout.toString(opts.encoding);
      stderr = stderr.toString(opts.encoding);
      if (code === 0) {
        resolve({ stdout: stdout, stderr: stderr, code: code });
      } else {
        var err = new Error('Command \'' + rep + '\' exited with code ' + code);
        err = _Object$assign(err, { stdout: stdout, stderr: stderr, code: code });
        reject(err);
      }
    });

    // if we set a timeout on the child process, cut into the execution and
    // reject if the timeout is reached. Attach the stdout/stderr we currently
    // have in case it's helpful in debugging
    if (opts.timeout) {
      timer = setTimeout(function () {
        stdout = stdout.toString(opts.encoding);
        stderr = stderr.toString(opts.encoding);
        var err = new Error('Command \'' + rep + '\' timed out after ' + opts.timeout + 'ms');
        err = _Object$assign(err, { stdout: stdout, stderr: stderr, code: null });
        reject(err);
        // reject and THEN kill to avoid race conditions with the handlers
        // above
        proc.kill(opts.killSignal);
      }, opts.timeout);
    }
  });
}

var SubProcess = (function (_EventEmitter) {
  function SubProcess(cmd) {
    var args = arguments[1] === undefined ? [] : arguments[1];
    var opts = arguments[2] === undefined ? {} : arguments[2];

    _classCallCheck(this, SubProcess);

    _get(Object.getPrototypeOf(SubProcess.prototype), 'constructor', this).call(this);
    if (!cmd) throw new Error('Command is required');
    if (typeof cmd !== 'string') throw new Error('Command must be a string');
    if (!(args instanceof Array)) throw new Error('Args must be an array');
    this.cmd = cmd;
    this.args = args;
    this.proc = null;
    this.opts = opts;
  }

  _inherits(SubProcess, _EventEmitter);

  _createClass(SubProcess, [{
    key: 'start',

    // spawn the subprocess and return control whenever we deem that it has fully
    // "started"
    value: function start() {
      var startDetector = arguments[0] === undefined ? null : arguments[0];
      var timeoutMs = arguments[1] === undefined ? null : arguments[1];
      var startDelay;
      return _regeneratorRuntime.async(function start$(context$2$0) {
        var _this = this;

        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            startDelay = 10;

            // the default start detector simply returns true when we get any output
            if (startDetector === null) {
              startDetector = function (stdout, stderr) {
                return stdout || stderr;
              };
            }

            // if the user passes a number, then we simply delay a certain amount of
            // time before returning control, rather than waiting for a condition
            if (typeof startDetector === 'number') {
              startDelay = startDetector;
              startDetector = null;
            }

            return context$2$0.abrupt('return', new _Promise(function (resolve, reject) {
              try {
                // actually spawn the subproc
                _this.proc = _child_process.spawn(_this.cmd, _this.args, _this.opts);
              } catch (e) {
                reject(e);
              }
              _this.proc.stdout.setEncoding('utf8');
              _this.proc.stderr.setEncoding('utf8');
              _this.lastLinePortion = { stdout: '', stderr: '' };

              // this function handles output that we collect from the subproc
              var handleOutput = function handleOutput(data) {
                // if we have a startDetector, run it on the output so we can resolve/
                // reject and move on from start
                try {
                  if (startDetector && startDetector(data.stdout, data.stderr)) {
                    resolve();
                  }
                } catch (e) {
                  reject(e);
                }

                // emit the actual output for whomever's listening
                _this.emit('output', data.stdout, data.stderr);

                // we also want to emit lines, but it's more complex since output
                // comes in chunks and a line could come in two different chunks, so
                // we have logic to handle that case (using this.lastLinePortion to
                // remember a line that started but did not finish in the last chunk)
                var _arr = ['stdout', 'stderr'];
                for (var _i = 0; _i < _arr.length; _i++) {
                  var stream = _arr[_i];
                  if (!data[stream]) continue;
                  var lines = data[stream].split('\n');
                  if (lines.length > 1) {
                    var retLines = lines.slice(0, -1);
                    retLines[0] = _this.lastLinePortion[stream] + retLines[0];
                    _this.lastLinePortion[stream] = lines[lines.length - 1];
                    _this.emit('lines-' + stream, retLines);
                  } else {
                    _this.lastLinePortion[stream] += lines[0];
                  }
                }
              };

              // if we get an error spawning the proc, reject and clean up the proc
              _this.proc.on('error', function (err) {
                _this.proc.removeAllListeners('exit');
                _this.proc.kill('SIGINT');
                reject(err);
              });

              _this.proc.stdout.pipe(_through2['default'](function (stdout) {
                handleOutput({ stdout: stdout, stderr: '' });
              }));

              _this.proc.stderr.pipe(_through2['default'](function (stderr) {
                handleOutput({ stdout: '', stderr: stderr });
              }));

              // when the proc exits, we might still have a buffer of lines we were
              // waiting on more chunks to complete. Go ahead and emit those, then
              // re-emit the exit so a listener can handle the possibly-unexpected exit
              _this.proc.on('exit', function (code, signal) {
                _this.handleLastLines();
                _this.emit('exit', code, signal);
                _this.proc = null;
              });

              // if the user hasn't given us a startDetector, instead just resolve
              // when startDelay ms have passed
              if (!startDetector) {
                setTimeout(function () {
                  resolve();
                }, startDelay);
              }

              // if the user has given us a timeout, start the clock for rejecting
              // the promise if we take too long to start
              if (typeof timeoutMs === 'number') {
                setTimeout(function () {
                  reject(new Error('The process did not start in the allotted time ' + ('(' + timeoutMs + 'ms)')));
                }, timeoutMs);
              }
            }));

          case 4:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'handleLastLines',
    value: function handleLastLines() {
      var _arr2 = ['stdout', 'stderr'];

      for (var _i2 = 0; _i2 < _arr2.length; _i2++) {
        var stream = _arr2[_i2];
        if (this.lastLinePortion[stream]) {
          this.emit('lines-' + stream, [this.lastLinePortion[stream]]);
          this.lastLinePortion[stream] = '';
        }
      }
    }
  }, {
    key: 'stop',
    value: function stop() {
      var signal = arguments[0] === undefined ? 'SIGTERM' : arguments[0];
      var timeout = arguments[1] === undefined ? 10000 : arguments[1];
      return _regeneratorRuntime.async(function stop$(context$2$0) {
        var _this2 = this;

        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            if (this.proc) {
              context$2$0.next = 2;
              break;
            }

            throw new Error('Can\'t stop process; it\'s not currently running');

          case 2:
            // make sure to emit any data in our lines buffer whenever we're done with
            // the proc
            this.handleLastLines();
            return context$2$0.abrupt('return', new _Promise(function (resolve, reject) {
              _this2.proc.on('close', resolve);
              _this2.proc.kill(signal);
              setTimeout(function () {
                reject(new Error('Process didn\'t end after ' + timeout + 'ms'));
              }, timeout);
            }));

          case 4:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'join',
    value: function join() {
      var allowedExitCodes = arguments[0] === undefined ? [0] : arguments[0];
      return _regeneratorRuntime.async(function join$(context$2$0) {
        var _this3 = this;

        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            if (this.proc) {
              context$2$0.next = 2;
              break;
            }

            throw new Error('Can\'t join process; it\'s not currently running');

          case 2:
            return context$2$0.abrupt('return', new _Promise(function (resolve, reject) {
              _this3.proc.on('exit', function (code) {
                if (allowedExitCodes.indexOf(code) === -1) {
                  reject(new Error('Process ended with exitcode ' + code));
                } else {
                  resolve(code);
                }
              });
            }));

          case 3:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }]);

  return SubProcess;
})(EventEmitter);

exports.exec = exec;
exports.spawn = _child_process.spawn;
exports.SubProcess = SubProcess;
// return a promise so we can wrap the async behavior
//# sourceMappingURL=data:application/json;base64,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LG9CQUFJLGdCQUFnQixDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRTtBQUN6Qyx3QkFBTSxDQUFDLElBQUksS0FBSyxrQ0FBZ0MsSUFBSSxDQUFHLENBQUMsQ0FBQztpQkFDMUQsTUFBTTtBQUNMLHlCQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7aUJBQ2Y7ZUFDRixDQUFDLENBQUM7YUFDSixDQUFDOzs7Ozs7O0tBQ0g7OztTQTlKRyxVQUFVO0dBQVMsWUFBWTs7UUFpSzVCLElBQUksR0FBSixJQUFJO1FBQUUsS0FBSyxrQkFqUFgsS0FBSztRQWlQUSxVQUFVLEdBQVYsVUFBVSIsImZpbGUiOiJsaWIvdGVlbl9wcm9jZXNzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc3Bhd24gfSBmcm9tICdjaGlsZF9wcm9jZXNzJztcbmltcG9ydCB7IHF1b3RlIH0gZnJvbSAnc2hlbGwtcXVvdGUnO1xuaW1wb3J0IGV2ZW50cyBmcm9tICdldmVudHMnO1xuaW1wb3J0IHRocm91Z2ggZnJvbSAndGhyb3VnaCc7XG5jb25zdCB7IEV2ZW50RW1pdHRlciB9ID0gZXZlbnRzO1xuXG5mdW5jdGlvbiBleGVjIChjbWQsIGFyZ3MgPSBbXSwgb3B0cyA9IHt9KSB7XG4gIC8vIGdldCBhIHF1b3RlZCByZXByZXNlbnRhdGlvbiBvZiB0aGUgY29tbWFuZCBmb3IgZXJyb3Igc3RyaW5nc1xuICBsZXQgcmVwID0gcXVvdGUoW2NtZF0uY29uY2F0KGFyZ3MpKTtcblxuICAvLyBleHRlbmQgZGVmYXVsdCBvcHRpb25zOyB3ZSdyZSBiYXNpY2FsbHkgcmUtaW1wbGVtZW50aW5nIGV4ZWMncyBvcHRpb25zXG4gIC8vIGZvciB1c2UgaGVyZSB3aXRoIHNwYXduIHVuZGVyIHRoZSBob29kXG4gIG9wdHMgPSBPYmplY3QuYXNzaWduKHtcbiAgICB0aW1lb3V0OiBudWxsLFxuICAgIGVuY29kaW5nOiAndXRmOCcsXG4gICAga2lsbFNpZ25hbDogJ1NJR1RFUk0nLFxuICAgIGN3ZDogdW5kZWZpbmVkLFxuICAgIGVudjogcHJvY2Vzcy5lbnYsXG4gICAgaWdub3JlT3V0cHV0OiBmYWxzZVxuICB9LCBvcHRzKTtcblxuICAvLyB0aGlzIGlzIGFuIGFzeW5jIGZ1bmN0aW9uLCBzbyByZXR1cm4gYSBwcm9taXNlXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgLy8gc3Bhd24gdGhlIGNoaWxkIHByb2Nlc3Mgd2l0aCBvcHRpb25zOyB3ZSBkb24ndCBjdXJyZW50bHkgZXhwb3NlIGFueSBvZlxuICAgIC8vIHRoZSBvdGhlciAnc3Bhd24nIG9wdGlvbnMgdGhyb3VnaCB0aGUgQVBJXG4gICAgbGV0IHByb2MgPSBzcGF3bihjbWQsIGFyZ3MsIHtjd2Q6IG9wdHMuY3dkLCBlbnY6IG9wdHMuZW52fSk7XG4gICAgbGV0IHN0ZG91dCA9IFwiXCIsIHN0ZGVyciA9IFwiXCIsIHRpbWVyID0gbnVsbDtcblxuICAgIC8vIGlmIHRoZSBwcm9jZXNzIGVycm9ycyBvdXQsIHJlamVjdCB0aGUgcHJvbWlzZVxuICAgIHByb2Mub24oJ2Vycm9yJywgKGVycikgPT4ge1xuICAgICAgcmVqZWN0KG5ldyBFcnJvcihgQ29tbWFuZCAnJHtyZXB9JyBlcnJvcmVkIG91dDogJHtlcnIuc3RhY2t9YCkpO1xuICAgIH0pO1xuXG4gICAgLy8ga2VlcCB0cmFjayBvZiBzdGRvdXQvc3RkZXJyIGlmIHdlIGhhdmVuJ3Qgc2FpZCBub3QgdG9cbiAgICBpZiAoIW9wdHMuaWdub3JlT3V0cHV0KSB7XG4gICAgICBwcm9jLnN0ZG91dC5vbignZGF0YScsIChkYXRhKSA9PiB7XG4gICAgICAgIHN0ZG91dCArPSBkYXRhO1xuICAgICAgfSk7XG4gICAgICBwcm9jLnN0ZGVyci5vbignZGF0YScsIChkYXRhKSA9PiB7XG4gICAgICAgIHN0ZGVyciArPSBkYXRhO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gaWYgdGhlIHByb2Nlc3MgZW5kcywgZWl0aGVyIHJlc29sdmUgb3IgcmVqZWN0IHRoZSBwcm9taXNlIGJhc2VkIG9uIHRoZVxuICAgIC8vIGV4aXQgY29kZSBvZiB0aGUgcHJvY2Vzcy4gZWl0aGVyIHdheSwgYXR0YWNoIHN0ZG91dCwgc3RkZXJyLCBhbmQgY29kZS5cbiAgICAvLyBBbHNvIGNsZWFuIHVwIHRoZSB0aW1lciBpZiBpdCBleGlzdHNcbiAgICBwcm9jLm9uKCdjbG9zZScsIChjb2RlKSA9PiB7XG4gICAgICBpZiAodGltZXIpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgIH1cbiAgICAgIHN0ZG91dCA9IHN0ZG91dC50b1N0cmluZyhvcHRzLmVuY29kaW5nKTtcbiAgICAgIHN0ZGVyciA9IHN0ZGVyci50b1N0cmluZyhvcHRzLmVuY29kaW5nKTtcbiAgICAgIGlmIChjb2RlID09PSAwKSB7XG4gICAgICAgIHJlc29sdmUoe3N0ZG91dCwgc3RkZXJyLCBjb2RlfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgZXJyID0gbmV3IEVycm9yKGBDb21tYW5kICcke3JlcH0nIGV4aXRlZCB3aXRoIGNvZGUgJHtjb2RlfWApO1xuICAgICAgICBlcnIgPSBPYmplY3QuYXNzaWduKGVyciwge3N0ZG91dCwgc3RkZXJyLCBjb2RlfSk7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gaWYgd2Ugc2V0IGEgdGltZW91dCBvbiB0aGUgY2hpbGQgcHJvY2VzcywgY3V0IGludG8gdGhlIGV4ZWN1dGlvbiBhbmRcbiAgICAvLyByZWplY3QgaWYgdGhlIHRpbWVvdXQgaXMgcmVhY2hlZC4gQXR0YWNoIHRoZSBzdGRvdXQvc3RkZXJyIHdlIGN1cnJlbnRseVxuICAgIC8vIGhhdmUgaW4gY2FzZSBpdCdzIGhlbHBmdWwgaW4gZGVidWdnaW5nXG4gICAgaWYgKG9wdHMudGltZW91dCkge1xuICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgc3Rkb3V0ID0gc3Rkb3V0LnRvU3RyaW5nKG9wdHMuZW5jb2RpbmcpO1xuICAgICAgICBzdGRlcnIgPSBzdGRlcnIudG9TdHJpbmcob3B0cy5lbmNvZGluZyk7XG4gICAgICAgIGxldCBlcnIgPSBuZXcgRXJyb3IoYENvbW1hbmQgJyR7cmVwfScgdGltZWQgb3V0IGFmdGVyICR7b3B0cy50aW1lb3V0fWAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBtc2ApO1xuICAgICAgICBlcnIgPSBPYmplY3QuYXNzaWduKGVyciwge3N0ZG91dCwgc3RkZXJyLCBjb2RlOiBudWxsfSk7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAvLyByZWplY3QgYW5kIFRIRU4ga2lsbCB0byBhdm9pZCByYWNlIGNvbmRpdGlvbnMgd2l0aCB0aGUgaGFuZGxlcnNcbiAgICAgICAgLy8gYWJvdmVcbiAgICAgICAgcHJvYy5raWxsKG9wdHMua2lsbFNpZ25hbCk7XG4gICAgICB9LCBvcHRzLnRpbWVvdXQpO1xuICAgIH1cbiAgfSk7XG59XG5cbmNsYXNzIFN1YlByb2Nlc3MgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvciAoY21kLCBhcmdzID0gW10sIG9wdHMgPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgaWYgKCFjbWQpIHRocm93IG5ldyBFcnJvcihcIkNvbW1hbmQgaXMgcmVxdWlyZWRcIik7XG4gICAgaWYgKHR5cGVvZiBjbWQgIT09IFwic3RyaW5nXCIpIHRocm93IG5ldyBFcnJvcihcIkNvbW1hbmQgbXVzdCBiZSBhIHN0cmluZ1wiKTtcbiAgICBpZiAoIShhcmdzIGluc3RhbmNlb2YgQXJyYXkpKSB0aHJvdyBuZXcgRXJyb3IoXCJBcmdzIG11c3QgYmUgYW4gYXJyYXlcIik7XG4gICAgdGhpcy5jbWQgPSBjbWQ7XG4gICAgdGhpcy5hcmdzID0gYXJncztcbiAgICB0aGlzLnByb2MgPSBudWxsO1xuICAgIHRoaXMub3B0cyA9IG9wdHM7XG4gIH1cblxuICAvLyBzcGF3biB0aGUgc3VicHJvY2VzcyBhbmQgcmV0dXJuIGNvbnRyb2wgd2hlbmV2ZXIgd2UgZGVlbSB0aGF0IGl0IGhhcyBmdWxseVxuICAvLyBcInN0YXJ0ZWRcIlxuICBhc3luYyBzdGFydCAoc3RhcnREZXRlY3RvciA9IG51bGwsIHRpbWVvdXRNcyA9IG51bGwpIHtcbiAgICBsZXQgc3RhcnREZWxheSA9IDEwO1xuXG4gICAgLy8gdGhlIGRlZmF1bHQgc3RhcnQgZGV0ZWN0b3Igc2ltcGx5IHJldHVybnMgdHJ1ZSB3aGVuIHdlIGdldCBhbnkgb3V0cHV0XG4gICAgaWYgKHN0YXJ0RGV0ZWN0b3IgPT09IG51bGwpIHtcbiAgICAgIHN0YXJ0RGV0ZWN0b3IgPSAoc3Rkb3V0LCBzdGRlcnIpID0+IHtcbiAgICAgICAgcmV0dXJuIHN0ZG91dCB8fCBzdGRlcnI7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIGlmIHRoZSB1c2VyIHBhc3NlcyBhIG51bWJlciwgdGhlbiB3ZSBzaW1wbHkgZGVsYXkgYSBjZXJ0YWluIGFtb3VudCBvZlxuICAgIC8vIHRpbWUgYmVmb3JlIHJldHVybmluZyBjb250cm9sLCByYXRoZXIgdGhhbiB3YWl0aW5nIGZvciBhIGNvbmRpdGlvblxuICAgIGlmICh0eXBlb2Ygc3RhcnREZXRlY3RvciA9PT0gJ251bWJlcicpIHtcbiAgICAgIHN0YXJ0RGVsYXkgPSBzdGFydERldGVjdG9yO1xuICAgICAgc3RhcnREZXRlY3RvciA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gcmV0dXJuIGEgcHJvbWlzZSBzbyB3ZSBjYW4gd3JhcCB0aGUgYXN5bmMgYmVoYXZpb3JcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gYWN0dWFsbHkgc3Bhd24gdGhlIHN1YnByb2NcbiAgICAgICAgdGhpcy5wcm9jID0gc3Bhd24odGhpcy5jbWQsIHRoaXMuYXJncywgdGhpcy5vcHRzKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgICAgdGhpcy5wcm9jLnN0ZG91dC5zZXRFbmNvZGluZygndXRmOCcpO1xuICAgICAgdGhpcy5wcm9jLnN0ZGVyci5zZXRFbmNvZGluZygndXRmOCcpO1xuICAgICAgdGhpcy5sYXN0TGluZVBvcnRpb24gPSB7c3Rkb3V0OiBcIlwiLCBzdGRlcnI6IFwiXCJ9O1xuXG4gICAgICAvLyB0aGlzIGZ1bmN0aW9uIGhhbmRsZXMgb3V0cHV0IHRoYXQgd2UgY29sbGVjdCBmcm9tIHRoZSBzdWJwcm9jXG4gICAgICBjb25zdCBoYW5kbGVPdXRwdXQgPSAoZGF0YSkgPT4ge1xuICAgICAgICAvLyBpZiB3ZSBoYXZlIGEgc3RhcnREZXRlY3RvciwgcnVuIGl0IG9uIHRoZSBvdXRwdXQgc28gd2UgY2FuIHJlc29sdmUvXG4gICAgICAgIC8vIHJlamVjdCBhbmQgbW92ZSBvbiBmcm9tIHN0YXJ0XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKHN0YXJ0RGV0ZWN0b3IgJiYgc3RhcnREZXRlY3RvcihkYXRhLnN0ZG91dCwgZGF0YS5zdGRlcnIpKSB7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZW1pdCB0aGUgYWN0dWFsIG91dHB1dCBmb3Igd2hvbWV2ZXIncyBsaXN0ZW5pbmdcbiAgICAgICAgdGhpcy5lbWl0KCdvdXRwdXQnLCBkYXRhLnN0ZG91dCwgZGF0YS5zdGRlcnIpO1xuXG4gICAgICAgIC8vIHdlIGFsc28gd2FudCB0byBlbWl0IGxpbmVzLCBidXQgaXQncyBtb3JlIGNvbXBsZXggc2luY2Ugb3V0cHV0XG4gICAgICAgIC8vIGNvbWVzIGluIGNodW5rcyBhbmQgYSBsaW5lIGNvdWxkIGNvbWUgaW4gdHdvIGRpZmZlcmVudCBjaHVua3MsIHNvXG4gICAgICAgIC8vIHdlIGhhdmUgbG9naWMgdG8gaGFuZGxlIHRoYXQgY2FzZSAodXNpbmcgdGhpcy5sYXN0TGluZVBvcnRpb24gdG9cbiAgICAgICAgLy8gcmVtZW1iZXIgYSBsaW5lIHRoYXQgc3RhcnRlZCBidXQgZGlkIG5vdCBmaW5pc2ggaW4gdGhlIGxhc3QgY2h1bmspXG4gICAgICAgIGZvciAobGV0IHN0cmVhbSBvZiBbJ3N0ZG91dCcsICdzdGRlcnInXSkge1xuICAgICAgICAgIGlmICghZGF0YVtzdHJlYW1dKSBjb250aW51ZTtcbiAgICAgICAgICBsZXQgbGluZXMgPSBkYXRhW3N0cmVhbV0uc3BsaXQoXCJcXG5cIik7XG4gICAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGxldCByZXRMaW5lcyA9IGxpbmVzLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgICAgIHJldExpbmVzWzBdID0gdGhpcy5sYXN0TGluZVBvcnRpb25bc3RyZWFtXSArIHJldExpbmVzWzBdO1xuICAgICAgICAgICAgdGhpcy5sYXN0TGluZVBvcnRpb25bc3RyZWFtXSA9IGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgdGhpcy5lbWl0KGBsaW5lcy0ke3N0cmVhbX1gLCByZXRMaW5lcyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubGFzdExpbmVQb3J0aW9uW3N0cmVhbV0gKz0gbGluZXNbMF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvLyBpZiB3ZSBnZXQgYW4gZXJyb3Igc3Bhd25pbmcgdGhlIHByb2MsIHJlamVjdCBhbmQgY2xlYW4gdXAgdGhlIHByb2NcbiAgICAgIHRoaXMucHJvYy5vbignZXJyb3InLCBlcnIgPT4ge1xuICAgICAgICB0aGlzLnByb2MucmVtb3ZlQWxsTGlzdGVuZXJzKCdleGl0Jyk7XG4gICAgICAgIHRoaXMucHJvYy5raWxsKCdTSUdJTlQnKTtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5wcm9jLnN0ZG91dC5waXBlKHRocm91Z2goc3Rkb3V0ID0+IHtcbiAgICAgICAgaGFuZGxlT3V0cHV0KHtzdGRvdXQsIHN0ZGVycjogJyd9KTtcbiAgICAgIH0pKTtcblxuICAgICAgdGhpcy5wcm9jLnN0ZGVyci5waXBlKHRocm91Z2goc3RkZXJyID0+IHtcbiAgICAgICAgaGFuZGxlT3V0cHV0KHtzdGRvdXQ6ICcnLCBzdGRlcnJ9KTtcbiAgICAgIH0pKTtcblxuICAgICAgLy8gd2hlbiB0aGUgcHJvYyBleGl0cywgd2UgbWlnaHQgc3RpbGwgaGF2ZSBhIGJ1ZmZlciBvZiBsaW5lcyB3ZSB3ZXJlXG4gICAgICAvLyB3YWl0aW5nIG9uIG1vcmUgY2h1bmtzIHRvIGNvbXBsZXRlLiBHbyBhaGVhZCBhbmQgZW1pdCB0aG9zZSwgdGhlblxuICAgICAgLy8gcmUtZW1pdCB0aGUgZXhpdCBzbyBhIGxpc3RlbmVyIGNhbiBoYW5kbGUgdGhlIHBvc3NpYmx5LXVuZXhwZWN0ZWQgZXhpdFxuICAgICAgdGhpcy5wcm9jLm9uKCdleGl0JywgKGNvZGUsIHNpZ25hbCkgPT4ge1xuICAgICAgICB0aGlzLmhhbmRsZUxhc3RMaW5lcygpO1xuICAgICAgICB0aGlzLmVtaXQoJ2V4aXQnLCBjb2RlLCBzaWduYWwpO1xuICAgICAgICB0aGlzLnByb2MgPSBudWxsO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIGlmIHRoZSB1c2VyIGhhc24ndCBnaXZlbiB1cyBhIHN0YXJ0RGV0ZWN0b3IsIGluc3RlYWQganVzdCByZXNvbHZlXG4gICAgICAvLyB3aGVuIHN0YXJ0RGVsYXkgbXMgaGF2ZSBwYXNzZWRcbiAgICAgIGlmICghc3RhcnREZXRlY3Rvcikge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0sIHN0YXJ0RGVsYXkpO1xuICAgICAgfVxuXG4gICAgICAvLyBpZiB0aGUgdXNlciBoYXMgZ2l2ZW4gdXMgYSB0aW1lb3V0LCBzdGFydCB0aGUgY2xvY2sgZm9yIHJlamVjdGluZ1xuICAgICAgLy8gdGhlIHByb21pc2UgaWYgd2UgdGFrZSB0b28gbG9uZyB0byBzdGFydFxuICAgICAgaWYgKHR5cGVvZiB0aW1lb3V0TXMgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIlRoZSBwcm9jZXNzIGRpZCBub3Qgc3RhcnQgaW4gdGhlIGFsbG90dGVkIHRpbWUgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgYCgke3RpbWVvdXRNc31tcylgKSk7XG4gICAgICAgIH0sIHRpbWVvdXRNcyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBoYW5kbGVMYXN0TGluZXMgKCkge1xuICAgIGZvciAobGV0IHN0cmVhbSBvZiBbJ3N0ZG91dCcsICdzdGRlcnInXSkge1xuICAgICAgaWYgKHRoaXMubGFzdExpbmVQb3J0aW9uW3N0cmVhbV0pIHtcbiAgICAgICAgdGhpcy5lbWl0KGBsaW5lcy0ke3N0cmVhbX1gLCBbdGhpcy5sYXN0TGluZVBvcnRpb25bc3RyZWFtXV0pO1xuICAgICAgICB0aGlzLmxhc3RMaW5lUG9ydGlvbltzdHJlYW1dID0gJyc7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgc3RvcCAoc2lnbmFsID0gJ1NJR1RFUk0nLCB0aW1lb3V0ID0gMTAwMDApIHtcbiAgICBpZiAoIXRoaXMucHJvYykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3Qgc3RvcCBwcm9jZXNzOyBpdCdzIG5vdCBjdXJyZW50bHkgcnVubmluZ1wiKTtcbiAgICB9XG4gICAgLy8gbWFrZSBzdXJlIHRvIGVtaXQgYW55IGRhdGEgaW4gb3VyIGxpbmVzIGJ1ZmZlciB3aGVuZXZlciB3ZSdyZSBkb25lIHdpdGhcbiAgICAvLyB0aGUgcHJvY1xuICAgIHRoaXMuaGFuZGxlTGFzdExpbmVzKCk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMucHJvYy5vbignY2xvc2UnLCByZXNvbHZlKTtcbiAgICAgIHRoaXMucHJvYy5raWxsKHNpZ25hbCk7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihgUHJvY2VzcyBkaWRuJ3QgZW5kIGFmdGVyICR7dGltZW91dH1tc2ApKTtcbiAgICAgIH0sIHRpbWVvdXQpO1xuICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgam9pbiAoYWxsb3dlZEV4aXRDb2RlcyA9IFswXSkge1xuICAgIGlmICghdGhpcy5wcm9jKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBqb2luIHByb2Nlc3M7IGl0J3Mgbm90IGN1cnJlbnRseSBydW5uaW5nXCIpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLnByb2Mub24oJ2V4aXQnLCAoY29kZSkgPT4ge1xuICAgICAgICBpZiAoYWxsb3dlZEV4aXRDb2Rlcy5pbmRleE9mKGNvZGUpID09PSAtMSkge1xuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoYFByb2Nlc3MgZW5kZWQgd2l0aCBleGl0Y29kZSAke2NvZGV9YCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc29sdmUoY29kZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCB7IGV4ZWMsIHNwYXduLCBTdWJQcm9jZXNzIH07XG4iXX0=