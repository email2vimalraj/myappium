'use strict';

var _slicedToArray = require('babel-runtime/helpers/sliced-to-array')['default'];

var _Object$defineProperty = require('babel-runtime/core-js/object/define-property')['default'];

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

_Object$defineProperty(exports, '__esModule', {
  value: true
});

var _npmlog = require('npmlog');

var _npmlog2 = _interopRequireDefault(_npmlog);

var _appiumSupport = require('appium-support');

var _appiumSupport2 = _interopRequireDefault(_appiumSupport);

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _denodeify = require('denodeify');

var _denodeify2 = _interopRequireDefault(_denodeify);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _asyncbox = require('asyncbox');

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _plist = require('plist');

var _plist2 = _interopRequireDefault(_plist);

var exec = _appiumSupport2['default'].core.exec;
var util = _appiumSupport2['default'].util;
var fileExists = _appiumSupport2['default'].util.fileExists;
var escapeSpace = _appiumSupport2['default'].util.escapeSpace;
var readSymlink = (0, _denodeify2['default'])(_fs2['default'].readlink);
var env = process.env;

var XCODE_SELECT_TIMEOUT = 3000;
var XCODE_SUBDIR = '/Contents/Developer';
var DEFAULT_NUMBER_OF_RETRIES = 3;

var log = process.env.GLOBAL_NPMLOG ? global.log : _npmlog2['default'];

function hasExpectedSubDir(path) {
  return path.substring(path.length - XCODE_SUBDIR.length) === XCODE_SUBDIR;
}

function getPathFromSymlink(failMessage) {
  var symlinkPath, legacySymlinkPath, xcodePath, customPath, mesg, msg;
  return _regeneratorRuntime.async(function getPathFromSymlink$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        // Node's invocation of xcode-select sometimes flakes and returns an empty string.
        // Not clear why. As a workaround, Appium can reliably deduce the version in use by checking
        // the locations xcode-select uses to store the selected version's path. This should be 100%
        // reliable so long as the link locations remain the same. However, since we're relying on
        // hardcoded paths, this approach will break the next time Apple changes the symlink location.
        log.warn('Finding XcodePath by symlink because ' + failMessage);

        symlinkPath = '/var/db/xcode_select_link';
        legacySymlinkPath = '/usr/share/xcode-select/xcode_dir_link';
        xcodePath = null;

        if (!util.hasContent(env.DEVELOPER_DIR)) {
          context$1$0.next = 17;
          break;
        }

        customPath = hasExpectedSubDir(env.DEVELOPER_DIR) ? env.DEVELOPER_DIR : env.DEVELOPER_DIR + XCODE_SUBDIR;
        context$1$0.next = 8;
        return _regeneratorRuntime.awrap(fileExists(customPath));

      case 8:
        if (!context$1$0.sent) {
          context$1$0.next = 12;
          break;
        }

        xcodePath = customPath;
        context$1$0.next = 15;
        break;

      case 12:
        mesg = 'Could not find path to Xcode, environment variable ' + ('DEVELOPER_DIR set to: ' + env.DEVELOPER_DIR + ' ') + 'but no Xcode found';

        log.warn(mesg);
        throw new Error(mesg);

      case 15:
        context$1$0.next = 27;
        break;

      case 17:
        context$1$0.next = 19;
        return _regeneratorRuntime.awrap(fileExists(symlinkPath));

      case 19:
        if (!context$1$0.sent) {
          context$1$0.next = 23;
          break;
        }

        xcodePath = readSymlink(symlinkPath);
        context$1$0.next = 27;
        break;

      case 23:
        context$1$0.next = 25;
        return _regeneratorRuntime.awrap(fileExists(legacySymlinkPath));

      case 25:
        if (!context$1$0.sent) {
          context$1$0.next = 27;
          break;
        }

        xcodePath = readSymlink(legacySymlinkPath);

      case 27:
        if (!xcodePath) {
          context$1$0.next = 29;
          break;
        }

        return context$1$0.abrupt('return', xcodePath.replace(new RegExp('/$'), '').trim());

      case 29:
        msg = 'Could not find path to Xcode by symlinks located in ' + symlinkPath + ', or ' + legacySymlinkPath;

        log.warn(msg);
        throw new Error(msg);

      case 32:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

function getPathFromXcodeSelect() {
  var _ref, _ref2, stdout, xcodeFolderPath, msg;

  return _regeneratorRuntime.async(function getPathFromXcodeSelect$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(exec('xcode-select --print-path', { maxBuffer: 524288, timeout: XCODE_SELECT_TIMEOUT }));

      case 2:
        _ref = context$1$0.sent;
        _ref2 = _slicedToArray(_ref, 1);
        stdout = _ref2[0];
        xcodeFolderPath = stdout.replace(new RegExp('/$'), '').trim();

        if (util.hasContent(xcodeFolderPath)) {
          context$1$0.next = 8;
          break;
        }

        throw new Error('xcode-select returned an empty string');

      case 8:
        context$1$0.next = 10;
        return _regeneratorRuntime.awrap(fileExists(xcodeFolderPath));

      case 10:
        if (!context$1$0.sent) {
          context$1$0.next = 14;
          break;
        }

        return context$1$0.abrupt('return', xcodeFolderPath);

      case 14:
        msg = 'xcode-select could not find xcode. Path: ' + xcodeFolderPath + ' does not exist.';

        log.error(msg);
        throw new Error(msg);

      case 17:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

var getPath = _lodash2['default'].memoize(function () {

  // first we try using xcode-select to find the path
  // then we try using the symlinks that Apple has by default

  return getPathFromXcodeSelect()['catch'](getPathFromSymlink);
});

function getVersionWithoutRetry() {
  var xcodePath, plistPath, cmd, _ref3, _ref32, stdout, versionPattern, match;

  return _regeneratorRuntime.async(function getVersionWithoutRetry$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(getPath());

      case 2:
        xcodePath = context$1$0.sent;
        plistPath = _path2['default'].resolve(xcodePath, '..', 'Info.plist');
        context$1$0.next = 6;
        return _regeneratorRuntime.awrap(fileExists(plistPath));

      case 6:
        if (context$1$0.sent) {
          context$1$0.next = 8;
          break;
        }

        throw new Error('Could not get Xcode version. ' + plistPath + ' does not exist on disk.');

      case 8:
        cmd = '/usr/libexec/PlistBuddy -c \'Print CFBundleShortVersionString\' ' + escapeSpace(plistPath);
        context$1$0.next = 11;
        return _regeneratorRuntime.awrap(exec(cmd, { maxBuffer: 524288, timeout: XCODE_SELECT_TIMEOUT }));

      case 11:
        _ref3 = context$1$0.sent;
        _ref32 = _slicedToArray(_ref3, 1);
        stdout = _ref32[0];
        versionPattern = /\d\.\d\.*\d*/;
        match = stdout.match(versionPattern);

        if (!(match === null || !util.hasContent(match[0]))) {
          context$1$0.next = 18;
          break;
        }

        throw new Error('Could not parse Xcode version. xcodebuild output was: ' + stdout);

      case 18:
        return context$1$0.abrupt('return', match[0]);

      case 19:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

var getVersion = _lodash2['default'].memoize(function () {
  var retries = arguments[0] === undefined ? DEFAULT_NUMBER_OF_RETRIES : arguments[0];

  return (0, _asyncbox.retry)(retries, getVersionWithoutRetry);
});

function getAutomationTraceTemplatePathWithoutRetry() {
  var xcodePath, extensions, pathPrefix, pathSuffix, automationTraceTemplatePaths, msg;
  return _regeneratorRuntime.async(function getAutomationTraceTemplatePathWithoutRetry$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(getPath());

      case 2:
        xcodePath = context$1$0.sent;
        extensions = ['xrplugin', 'bundle'];
        pathPrefix = _path2['default'].resolve(xcodePath, '../Applications/Instruments.app/Contents/PlugIns');
        pathSuffix = 'Contents/Resources/Automation.tracetemplate';
        automationTraceTemplatePaths = [_path2['default'].resolve(pathPrefix, 'AutomationInstrument.' + extensions[0], pathSuffix), _path2['default'].resolve(pathPrefix, 'AutomationInstrument.' + extensions[1], pathSuffix)];
        context$1$0.next = 9;
        return _regeneratorRuntime.awrap(fileExists(automationTraceTemplatePaths[0]));

      case 9:
        if (!context$1$0.sent) {
          context$1$0.next = 11;
          break;
        }

        return context$1$0.abrupt('return', automationTraceTemplatePaths[0]);

      case 11:
        context$1$0.next = 13;
        return _regeneratorRuntime.awrap(fileExists(automationTraceTemplatePaths[1]));

      case 13:
        if (!context$1$0.sent) {
          context$1$0.next = 15;
          break;
        }

        return context$1$0.abrupt('return', automationTraceTemplatePaths[1]);

      case 15:
        msg = 'Could not find Automation.tracetemplate in any of the following' + ('locations ' + automationTraceTemplatePaths.toString());

        log.error(msg);
        throw new Error(msg);

      case 18:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

var getAutomationTraceTemplatePath = _lodash2['default'].memoize(function () {
  var retries = arguments[0] === undefined ? DEFAULT_NUMBER_OF_RETRIES : arguments[0];

  return (0, _asyncbox.retry)(retries, getAutomationTraceTemplatePathWithoutRetry);
});

function getMaxIOSSDKWithoutRetry() {
  var version, cmd, _ref4, _ref42, stdout, sdkVersion, match;

  return _regeneratorRuntime.async(function getMaxIOSSDKWithoutRetry$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(getVersion());

      case 2:
        version = context$1$0.sent;

        if (!(version[0] === '4')) {
          context$1$0.next = 5;
          break;
        }

        return context$1$0.abrupt('return', '6.1');

      case 5:
        cmd = 'xcrun --sdk iphonesimulator --show-sdk-version';
        context$1$0.next = 8;
        return _regeneratorRuntime.awrap(exec(cmd, { maxBuffer: 524288, timeout: XCODE_SELECT_TIMEOUT }));

      case 8:
        _ref4 = context$1$0.sent;
        _ref42 = _slicedToArray(_ref4, 1);
        stdout = _ref42[0];
        sdkVersion = stdout.trim();
        match = /\d.\d/.exec(stdout);

        if (match) {
          context$1$0.next = 15;
          break;
        }

        throw new Error('xcrun returned a non-numeric iOS SDK version: ' + sdkVersion);

      case 15:
        return context$1$0.abrupt('return', sdkVersion);

      case 16:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

var getMaxIOSSDK = _lodash2['default'].memoize(function () {
  var retries = arguments[0] === undefined ? DEFAULT_NUMBER_OF_RETRIES : arguments[0];

  return (0, _asyncbox.retry)(retries, getMaxIOSSDKWithoutRetry);
});

function getConnectedDevices() {
  var _ref5, _ref52, stdout, plistContent, devicesFound, entriesToSearch, currentEntry, deviceInfo;

  return _regeneratorRuntime.async(function getConnectedDevices$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
      case 0:
        context$1$0.next = 2;
        return _regeneratorRuntime.awrap(exec('/usr/sbin/system_profiler -xml SPUSBDataType', { maxBuffer: 524288, timeout: XCODE_SELECT_TIMEOUT }));

      case 2:
        _ref5 = context$1$0.sent;
        _ref52 = _slicedToArray(_ref5, 1);
        stdout = _ref52[0];
        plistContent = _plist2['default'].parse(stdout);
        devicesFound = [];
        entriesToSearch = [plistContent[0]];

        while (entriesToSearch.length > 0) {
          currentEntry = entriesToSearch.pop();

          if (currentEntry instanceof Array) {
            entriesToSearch = entriesToSearch.concat(currentEntry);
          } else if (currentEntry._name && currentEntry._name.substring(0, 4) === 'iPad' || currentEntry._name && currentEntry._name.substring(0, 6) === 'iPhone') {
            deviceInfo = {
              name: currentEntry._name,
              udid: currentEntry.serial_num,
              productId: currentEntry.product_id,
              deviceVersion: currentEntry.bcd_device
            };

            devicesFound.push(deviceInfo);
          } else if (currentEntry._items) {
            entriesToSearch = entriesToSearch.concat(currentEntry._items);
          }
        }
        return context$1$0.abrupt('return', devicesFound);

      case 10:
      case 'end':
        return context$1$0.stop();
    }
  }, null, this);
}

function clearInternalCache() {

  // memoized functions
  var memoized = [getPath, getVersion, getAutomationTraceTemplatePath, getMaxIOSSDK];

  memoized.forEach(function (f) {
    if (f.cache) {
      f.cache = new _lodash2['default'].memoize.Cache();
    }
  });
}

exports.getPath = getPath;
exports.getVersion = getVersion;
exports.getAutomationTraceTemplatePath = getAutomationTraceTemplatePath;
exports.getMaxIOSSDK = getMaxIOSSDK;
exports.getAutomationTraceTemplatePathWithoutRetry = getAutomationTraceTemplatePathWithoutRetry;
exports.getMaxIOSSDKWithoutRetry = getMaxIOSSDKWithoutRetry;
exports.getConnectedDevices = getConnectedDevices;
exports.clearInternalCache = clearInternalCache;
//  Xcode < 5.x

// xcode-select allows users to override its settings with the DEVELOPER_DIR env var,
// so check that first

// We should only get here is we failed to capture xcode-select's stdout and our
// other checks failed. Either Apple has moved the symlink to a new location or the user
// is not using the default install. 99.999% chance it's the latter, so issue a warning
// should we ever hit the edge case.

// trim and remove trailing slash

// we want to read the CFBundleShortVersionString from Xcode's plist.
// It should be in /[root]/XCode.app/Contents/

// need to use string#match here; previous code used regexp#exec, which does not return null

// for ios 8 and up, the file extension for AutiomationInstrument changed.
// rather than waste time getting the iOSSDKVersion, just get both paths and see which one exists
//# sourceMappingURL=data:application/json;base64,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QU0sQ0FBQyxDQUFDO1dBQy9EO1NBQ0Y7NENBQ00sWUFBWTs7Ozs7OztDQUNwQjs7QUFFRCxTQUFTLGtCQUFrQixHQUFJOzs7QUFHN0IsTUFBTSxRQUFRLEdBQUcsQ0FBQyxPQUFPLEVBQUUsVUFBVSxFQUFFLDhCQUE4QixFQUNuRCxZQUFZLENBQUMsQ0FBQzs7QUFFaEMsVUFBUSxDQUFDLE9BQU8sQ0FBQyxVQUFDLENBQUMsRUFBSztBQUN0QixRQUFJLENBQUMsQ0FBQyxLQUFLLEVBQUU7QUFDWCxPQUFDLENBQUMsS0FBSyxHQUFHLElBQUksb0JBQUUsT0FBTyxDQUFDLEtBQUssRUFBRSxDQUFDO0tBQ2pDO0dBQ0YsQ0FBQyxDQUFDO0NBR0o7O1FBRVEsT0FBTyxHQUFQLE9BQU87UUFBRSxVQUFVLEdBQVYsVUFBVTtRQUFFLDhCQUE4QixHQUE5Qiw4QkFBOEI7UUFBRSxZQUFZLEdBQVosWUFBWTtRQUNqRSwwQ0FBMEMsR0FBMUMsMENBQTBDO1FBQUUsd0JBQXdCLEdBQXhCLHdCQUF3QjtRQUNwRSxtQkFBbUIsR0FBbkIsbUJBQW1CO1FBQUUsa0JBQWtCLEdBQWxCLGtCQUFrQiIsImZpbGUiOiJsaWIveGNvZGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbnBtbG9nIGZyb20gJ25wbWxvZyc7XG5pbXBvcnQgc3VwcG9ydCBmcm9tICdhcHBpdW0tc3VwcG9ydCc7XG5pbXBvcnQgZnMgZnJvbSAnZnMnO1xuaW1wb3J0IGRlbm9kZWlmeSBmcm9tICdkZW5vZGVpZnknO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgeyByZXRyeSB9IGZyb20gJ2FzeW5jYm94JztcbmltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgcGxpc3QgZnJvbSAncGxpc3QnO1xuXG5jb25zdCBleGVjID0gc3VwcG9ydC5jb3JlLmV4ZWM7XG5jb25zdCB1dGlsID0gc3VwcG9ydC51dGlsO1xuY29uc3QgZmlsZUV4aXN0cyA9IHN1cHBvcnQudXRpbC5maWxlRXhpc3RzO1xuY29uc3QgZXNjYXBlU3BhY2UgPSBzdXBwb3J0LnV0aWwuZXNjYXBlU3BhY2U7XG5jb25zdCByZWFkU3ltbGluayA9IGRlbm9kZWlmeShmcy5yZWFkbGluayk7XG5jb25zdCBlbnYgPSBwcm9jZXNzLmVudjtcblxuY29uc3QgWENPREVfU0VMRUNUX1RJTUVPVVQgPSAzMDAwO1xuY29uc3QgWENPREVfU1VCRElSID0gXCIvQ29udGVudHMvRGV2ZWxvcGVyXCI7XG5jb25zdCBERUZBVUxUX05VTUJFUl9PRl9SRVRSSUVTID0gMztcblxuY29uc3QgbG9nID0gcHJvY2Vzcy5lbnYuR0xPQkFMX05QTUxPRyA/IGdsb2JhbC5sb2cgOiBucG1sb2c7XG5cblxuZnVuY3Rpb24gaGFzRXhwZWN0ZWRTdWJEaXIgKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGguc3Vic3RyaW5nKHBhdGgubGVuZ3RoIC0gWENPREVfU1VCRElSLmxlbmd0aCkgPT09IFhDT0RFX1NVQkRJUjtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZ2V0UGF0aEZyb21TeW1saW5rIChmYWlsTWVzc2FnZSkge1xuICAvLyBOb2RlJ3MgaW52b2NhdGlvbiBvZiB4Y29kZS1zZWxlY3Qgc29tZXRpbWVzIGZsYWtlcyBhbmQgcmV0dXJucyBhbiBlbXB0eSBzdHJpbmcuXG4gIC8vIE5vdCBjbGVhciB3aHkuIEFzIGEgd29ya2Fyb3VuZCwgQXBwaXVtIGNhbiByZWxpYWJseSBkZWR1Y2UgdGhlIHZlcnNpb24gaW4gdXNlIGJ5IGNoZWNraW5nXG4gIC8vIHRoZSBsb2NhdGlvbnMgeGNvZGUtc2VsZWN0IHVzZXMgdG8gc3RvcmUgdGhlIHNlbGVjdGVkIHZlcnNpb24ncyBwYXRoLiBUaGlzIHNob3VsZCBiZSAxMDAlXG4gIC8vIHJlbGlhYmxlIHNvIGxvbmcgYXMgdGhlIGxpbmsgbG9jYXRpb25zIHJlbWFpbiB0aGUgc2FtZS4gSG93ZXZlciwgc2luY2Ugd2UncmUgcmVseWluZyBvblxuICAvLyBoYXJkY29kZWQgcGF0aHMsIHRoaXMgYXBwcm9hY2ggd2lsbCBicmVhayB0aGUgbmV4dCB0aW1lIEFwcGxlIGNoYW5nZXMgdGhlIHN5bWxpbmsgbG9jYXRpb24uXG4gIGxvZy53YXJuKGBGaW5kaW5nIFhjb2RlUGF0aCBieSBzeW1saW5rIGJlY2F1c2UgJHtmYWlsTWVzc2FnZX1gKTtcblxuICBjb25zdCBzeW1saW5rUGF0aCA9IFwiL3Zhci9kYi94Y29kZV9zZWxlY3RfbGlua1wiO1xuICBjb25zdCBsZWdhY3lTeW1saW5rUGF0aCA9IFwiL3Vzci9zaGFyZS94Y29kZS1zZWxlY3QveGNvZGVfZGlyX2xpbmtcIjsgLy8gIFhjb2RlIDwgNS54XG4gIGxldCB4Y29kZVBhdGggPSBudWxsO1xuXG4gIC8vIHhjb2RlLXNlbGVjdCBhbGxvd3MgdXNlcnMgdG8gb3ZlcnJpZGUgaXRzIHNldHRpbmdzIHdpdGggdGhlIERFVkVMT1BFUl9ESVIgZW52IHZhcixcbiAgLy8gc28gY2hlY2sgdGhhdCBmaXJzdFxuICBpZiAodXRpbC5oYXNDb250ZW50KGVudi5ERVZFTE9QRVJfRElSKSkge1xuICAgIGNvbnN0IGN1c3RvbVBhdGggPSBoYXNFeHBlY3RlZFN1YkRpcihlbnYuREVWRUxPUEVSX0RJUikgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnYuREVWRUxPUEVSX0RJUiAgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnYuREVWRUxPUEVSX0RJUiArIFhDT0RFX1NVQkRJUjtcblxuICAgIGlmIChhd2FpdCBmaWxlRXhpc3RzKGN1c3RvbVBhdGgpKSB7XG4gICAgICB4Y29kZVBhdGggPSBjdXN0b21QYXRoO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgbWVzZyA9IGBDb3VsZCBub3QgZmluZCBwYXRoIHRvIFhjb2RlLCBlbnZpcm9ubWVudCB2YXJpYWJsZSBgICtcbiAgICAgICAgICAgICAgICAgYERFVkVMT1BFUl9ESVIgc2V0IHRvOiAke2Vudi5ERVZFTE9QRVJfRElSfSBgICtcbiAgICAgICAgICAgICAgICAgYGJ1dCBubyBYY29kZSBmb3VuZGA7XG4gICAgICBsb2cud2FybihtZXNnKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNnKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoYXdhaXQgZmlsZUV4aXN0cyhzeW1saW5rUGF0aCkpIHtcbiAgICB4Y29kZVBhdGggPSByZWFkU3ltbGluayhzeW1saW5rUGF0aCk7XG4gIH0gZWxzZSBpZiAoYXdhaXQgZmlsZUV4aXN0cyhsZWdhY3lTeW1saW5rUGF0aCkpIHtcbiAgICB4Y29kZVBhdGggPSByZWFkU3ltbGluayhsZWdhY3lTeW1saW5rUGF0aCk7XG4gIH1cblxuICBpZiAoeGNvZGVQYXRoKSB7XG4gICAgcmV0dXJuIHhjb2RlUGF0aC5yZXBsYWNlKG5ldyBSZWdFeHAoXCIvJFwiKSwgXCJcIikudHJpbSgpO1xuICB9XG5cbiAgLy8gV2Ugc2hvdWxkIG9ubHkgZ2V0IGhlcmUgaXMgd2UgZmFpbGVkIHRvIGNhcHR1cmUgeGNvZGUtc2VsZWN0J3Mgc3Rkb3V0IGFuZCBvdXJcbiAgLy8gb3RoZXIgY2hlY2tzIGZhaWxlZC4gRWl0aGVyIEFwcGxlIGhhcyBtb3ZlZCB0aGUgc3ltbGluayB0byBhIG5ldyBsb2NhdGlvbiBvciB0aGUgdXNlclxuICAvLyBpcyBub3QgdXNpbmcgdGhlIGRlZmF1bHQgaW5zdGFsbC4gOTkuOTk5JSBjaGFuY2UgaXQncyB0aGUgbGF0dGVyLCBzbyBpc3N1ZSBhIHdhcm5pbmdcbiAgLy8gc2hvdWxkIHdlIGV2ZXIgaGl0IHRoZSBlZGdlIGNhc2UuXG4gIGxldCBtc2cgPSBgQ291bGQgbm90IGZpbmQgcGF0aCB0byBYY29kZSBieSBzeW1saW5rcyBsb2NhdGVkIGluICR7c3ltbGlua1BhdGh9LCBvciAke2xlZ2FjeVN5bWxpbmtQYXRofWA7XG4gIGxvZy53YXJuKG1zZyk7XG4gIHRocm93IG5ldyBFcnJvcihtc2cpO1xuXG59XG5cbmFzeW5jIGZ1bmN0aW9uIGdldFBhdGhGcm9tWGNvZGVTZWxlY3QgKCkge1xuXG4gIGxldCBbc3Rkb3V0XSA9IGF3YWl0IGV4ZWMoJ3hjb2RlLXNlbGVjdCAtLXByaW50LXBhdGgnLCB7bWF4QnVmZmVyOiA1MjQyODgsIHRpbWVvdXQ6IFhDT0RFX1NFTEVDVF9USU1FT1VUfSk7XG5cbiAgLy8gdHJpbSBhbmQgcmVtb3ZlIHRyYWlsaW5nIHNsYXNoXG4gIGNvbnN0IHhjb2RlRm9sZGVyUGF0aCA9IHN0ZG91dC5yZXBsYWNlKG5ldyBSZWdFeHAoXCIvJFwiKSwgXCJcIikudHJpbSgpO1xuXG4gIGlmICghdXRpbC5oYXNDb250ZW50KHhjb2RlRm9sZGVyUGF0aCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ4Y29kZS1zZWxlY3QgcmV0dXJuZWQgYW4gZW1wdHkgc3RyaW5nXCIpO1xuICB9XG5cbiAgaWYgKGF3YWl0IGZpbGVFeGlzdHMoeGNvZGVGb2xkZXJQYXRoKSkge1xuICAgIHJldHVybiB4Y29kZUZvbGRlclBhdGg7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgbXNnID0gYHhjb2RlLXNlbGVjdCBjb3VsZCBub3QgZmluZCB4Y29kZS4gUGF0aDogJHt4Y29kZUZvbGRlclBhdGh9IGRvZXMgbm90IGV4aXN0LmA7XG4gICAgbG9nLmVycm9yKG1zZyk7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gIH1cbn1cblxuY29uc3QgZ2V0UGF0aCA9IF8ubWVtb2l6ZShmdW5jdGlvbiAoKSB7XG5cbiAgLy8gZmlyc3Qgd2UgdHJ5IHVzaW5nIHhjb2RlLXNlbGVjdCB0byBmaW5kIHRoZSBwYXRoXG4gIC8vIHRoZW4gd2UgdHJ5IHVzaW5nIHRoZSBzeW1saW5rcyB0aGF0IEFwcGxlIGhhcyBieSBkZWZhdWx0XG5cbiAgcmV0dXJuIGdldFBhdGhGcm9tWGNvZGVTZWxlY3QoKS5jYXRjaChnZXRQYXRoRnJvbVN5bWxpbmspO1xufSk7XG5cblxuXG5hc3luYyBmdW5jdGlvbiBnZXRWZXJzaW9uV2l0aG91dFJldHJ5ICgpIHtcblxuICBsZXQgeGNvZGVQYXRoID0gYXdhaXQgZ2V0UGF0aCgpO1xuXG4gIC8vIHdlIHdhbnQgdG8gcmVhZCB0aGUgQ0ZCdW5kbGVTaG9ydFZlcnNpb25TdHJpbmcgZnJvbSBYY29kZSdzIHBsaXN0LlxuICAvLyBJdCBzaG91bGQgYmUgaW4gL1tyb290XS9YQ29kZS5hcHAvQ29udGVudHMvXG4gIGNvbnN0IHBsaXN0UGF0aCA9IHBhdGgucmVzb2x2ZSh4Y29kZVBhdGgsIFwiLi5cIiwgXCJJbmZvLnBsaXN0XCIpO1xuXG4gIGlmICghYXdhaXQgZmlsZUV4aXN0cyhwbGlzdFBhdGgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZ2V0IFhjb2RlIHZlcnNpb24uICR7cGxpc3RQYXRofSBkb2VzIG5vdCBleGlzdCBvbiBkaXNrLmApO1xuICB9XG5cbiAgY29uc3QgY21kID0gYC91c3IvbGliZXhlYy9QbGlzdEJ1ZGR5IC1jICdQcmludCBDRkJ1bmRsZVNob3J0VmVyc2lvblN0cmluZycgJHtlc2NhcGVTcGFjZShwbGlzdFBhdGgpfWA7XG4gIGxldCBbc3Rkb3V0XSA9IGF3YWl0IGV4ZWMoY21kLCB7bWF4QnVmZmVyOiA1MjQyODgsIHRpbWVvdXQ6IFhDT0RFX1NFTEVDVF9USU1FT1VUfSk7XG5cbiAgbGV0IHZlcnNpb25QYXR0ZXJuID0gL1xcZFxcLlxcZFxcLipcXGQqLztcbiAgLy8gbmVlZCB0byB1c2Ugc3RyaW5nI21hdGNoIGhlcmU7IHByZXZpb3VzIGNvZGUgdXNlZCByZWdleHAjZXhlYywgd2hpY2ggZG9lcyBub3QgcmV0dXJuIG51bGxcbiAgbGV0IG1hdGNoID0gc3Rkb3V0Lm1hdGNoKHZlcnNpb25QYXR0ZXJuKTtcbiAgaWYgKG1hdGNoID09PSBudWxsIHx8ICF1dGlsLmhhc0NvbnRlbnQobWF0Y2hbMF0pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgcGFyc2UgWGNvZGUgdmVyc2lvbi4geGNvZGVidWlsZCBvdXRwdXQgd2FzOiAke3N0ZG91dH1gKTtcbiAgfVxuXG4gIHJldHVybiBtYXRjaFswXTtcbn1cblxuXG5jb25zdCBnZXRWZXJzaW9uID0gXy5tZW1vaXplKFxuICBmdW5jdGlvbiAocmV0cmllcyA9IERFRkFVTFRfTlVNQkVSX09GX1JFVFJJRVMpIHtcbiAgICByZXR1cm4gcmV0cnkocmV0cmllcywgZ2V0VmVyc2lvbldpdGhvdXRSZXRyeSk7XG4gIH1cbik7XG5cbmFzeW5jIGZ1bmN0aW9uIGdldEF1dG9tYXRpb25UcmFjZVRlbXBsYXRlUGF0aFdpdGhvdXRSZXRyeSAoKSB7XG5cbiAgY29uc3QgeGNvZGVQYXRoID0gYXdhaXQgZ2V0UGF0aCgpO1xuXG4gIC8vIGZvciBpb3MgOCBhbmQgdXAsIHRoZSBmaWxlIGV4dGVuc2lvbiBmb3IgQXV0aW9tYXRpb25JbnN0cnVtZW50IGNoYW5nZWQuXG4gIC8vIHJhdGhlciB0aGFuIHdhc3RlIHRpbWUgZ2V0dGluZyB0aGUgaU9TU0RLVmVyc2lvbiwganVzdCBnZXQgYm90aCBwYXRocyBhbmQgc2VlIHdoaWNoIG9uZSBleGlzdHNcbiAgY29uc3QgZXh0ZW5zaW9ucyA9IFsneHJwbHVnaW4nLCAnYnVuZGxlJ107XG4gIGNvbnN0IHBhdGhQcmVmaXggPSBwYXRoLnJlc29sdmUoeGNvZGVQYXRoLCBcIi4uL0FwcGxpY2F0aW9ucy9JbnN0cnVtZW50cy5hcHAvQ29udGVudHMvUGx1Z0luc1wiKTtcbiAgY29uc3QgcGF0aFN1ZmZpeCA9IFwiQ29udGVudHMvUmVzb3VyY2VzL0F1dG9tYXRpb24udHJhY2V0ZW1wbGF0ZVwiO1xuICBsZXQgYXV0b21hdGlvblRyYWNlVGVtcGxhdGVQYXRocyA9IFtcbiAgICBwYXRoLnJlc29sdmUocGF0aFByZWZpeCwgXCJBdXRvbWF0aW9uSW5zdHJ1bWVudC5cIiArIGV4dGVuc2lvbnNbMF0sIHBhdGhTdWZmaXgpLFxuICAgIHBhdGgucmVzb2x2ZShwYXRoUHJlZml4LCBcIkF1dG9tYXRpb25JbnN0cnVtZW50LlwiICsgZXh0ZW5zaW9uc1sxXSwgcGF0aFN1ZmZpeClcbiAgXTtcblxuICBpZiAoYXdhaXQgZmlsZUV4aXN0cyhhdXRvbWF0aW9uVHJhY2VUZW1wbGF0ZVBhdGhzWzBdKSkge1xuICAgIHJldHVybiBhdXRvbWF0aW9uVHJhY2VUZW1wbGF0ZVBhdGhzWzBdO1xuICB9XG5cbiAgaWYgKGF3YWl0IGZpbGVFeGlzdHMoYXV0b21hdGlvblRyYWNlVGVtcGxhdGVQYXRoc1sxXSkpIHtcbiAgICByZXR1cm4gYXV0b21hdGlvblRyYWNlVGVtcGxhdGVQYXRoc1sxXTtcbiAgfVxuXG4gIGNvbnN0IG1zZyA9IFwiQ291bGQgbm90IGZpbmQgQXV0b21hdGlvbi50cmFjZXRlbXBsYXRlIGluIGFueSBvZiB0aGUgZm9sbG93aW5nXCIgK1xuICAgICAgICAgICAgICBgbG9jYXRpb25zICR7YXV0b21hdGlvblRyYWNlVGVtcGxhdGVQYXRocy50b1N0cmluZygpfWA7XG4gIGxvZy5lcnJvcihtc2cpO1xuICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcblxufVxuXG5jb25zdCBnZXRBdXRvbWF0aW9uVHJhY2VUZW1wbGF0ZVBhdGggPSBfLm1lbW9pemUoXG4gIGZ1bmN0aW9uIChyZXRyaWVzID0gREVGQVVMVF9OVU1CRVJfT0ZfUkVUUklFUykge1xuICAgIHJldHVybiByZXRyeShyZXRyaWVzLCBnZXRBdXRvbWF0aW9uVHJhY2VUZW1wbGF0ZVBhdGhXaXRob3V0UmV0cnkpO1xuICB9XG4pO1xuXG5hc3luYyBmdW5jdGlvbiBnZXRNYXhJT1NTREtXaXRob3V0UmV0cnkgKCkge1xuXG4gIGNvbnN0IHZlcnNpb24gPSBhd2FpdCBnZXRWZXJzaW9uKCk7XG5cbiAgaWYgKHZlcnNpb25bMF0gPT09ICc0Jykge1xuICAgIHJldHVybiAnNi4xJztcbiAgfVxuXG4gIGNvbnN0IGNtZCA9IGB4Y3J1biAtLXNkayBpcGhvbmVzaW11bGF0b3IgLS1zaG93LXNkay12ZXJzaW9uYDtcbiAgY29uc3QgW3N0ZG91dF0gPSBhd2FpdCBleGVjKGNtZCwge21heEJ1ZmZlcjogNTI0Mjg4LCB0aW1lb3V0OiBYQ09ERV9TRUxFQ1RfVElNRU9VVH0pO1xuXG4gIGNvbnN0IHNka1ZlcnNpb24gPSBzdGRvdXQudHJpbSgpO1xuICBjb25zdCBtYXRjaCA9IC9cXGQuXFxkLy5leGVjKHN0ZG91dCk7XG5cbiAgaWYgKCFtYXRjaCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgeGNydW4gcmV0dXJuZWQgYSBub24tbnVtZXJpYyBpT1MgU0RLIHZlcnNpb246ICR7c2RrVmVyc2lvbn1gKTtcbiAgfVxuXG4gIHJldHVybiBzZGtWZXJzaW9uO1xufVxuXG5jb25zdCBnZXRNYXhJT1NTREsgPSBfLm1lbW9pemUoXG4gIGZ1bmN0aW9uIChyZXRyaWVzID0gREVGQVVMVF9OVU1CRVJfT0ZfUkVUUklFUykge1xuICAgIHJldHVybiByZXRyeShyZXRyaWVzLCBnZXRNYXhJT1NTREtXaXRob3V0UmV0cnkpO1xuICB9XG4pO1xuXG5hc3luYyBmdW5jdGlvbiBnZXRDb25uZWN0ZWREZXZpY2VzICgpIHtcblxuICBsZXQgW3N0ZG91dF0gPSBhd2FpdCBleGVjKCcvdXNyL3NiaW4vc3lzdGVtX3Byb2ZpbGVyIC14bWwgU1BVU0JEYXRhVHlwZScsXG4gICAge21heEJ1ZmZlcjogNTI0Mjg4LCB0aW1lb3V0OiBYQ09ERV9TRUxFQ1RfVElNRU9VVH0pO1xuICBsZXQgcGxpc3RDb250ZW50ID0gcGxpc3QucGFyc2Uoc3Rkb3V0KTtcblxuICBsZXQgZGV2aWNlc0ZvdW5kID0gW107XG4gIGxldCBlbnRyaWVzVG9TZWFyY2ggPSBbcGxpc3RDb250ZW50WzBdXTtcbiAgd2hpbGUgKGVudHJpZXNUb1NlYXJjaC5sZW5ndGggPiAwKSB7XG4gICAgbGV0IGN1cnJlbnRFbnRyeSA9IGVudHJpZXNUb1NlYXJjaC5wb3AoKTtcbiAgICBpZiAoY3VycmVudEVudHJ5IGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIGVudHJpZXNUb1NlYXJjaCA9IGVudHJpZXNUb1NlYXJjaC5jb25jYXQoY3VycmVudEVudHJ5KTtcbiAgICB9IGVsc2UgaWYgKChjdXJyZW50RW50cnkuX25hbWUgJiZcbiAgICAgICAgICAgICAgICBjdXJyZW50RW50cnkuX25hbWUuc3Vic3RyaW5nKDAsIDQpID09PSBcImlQYWRcIikgfHxcbiAgICAgICAgICAgICAgIChjdXJyZW50RW50cnkuX25hbWUgJiZcbiAgICAgICAgICAgICAgICBjdXJyZW50RW50cnkuX25hbWUuc3Vic3RyaW5nKDAsIDYpID09PSBcImlQaG9uZVwiKSkge1xuICAgICAgbGV0IGRldmljZUluZm8gPSB7XG4gICAgICAgIG5hbWU6IGN1cnJlbnRFbnRyeS5fbmFtZSxcbiAgICAgICAgdWRpZDogY3VycmVudEVudHJ5LnNlcmlhbF9udW0sXG4gICAgICAgIHByb2R1Y3RJZDogY3VycmVudEVudHJ5LnByb2R1Y3RfaWQsXG4gICAgICAgIGRldmljZVZlcnNpb246IGN1cnJlbnRFbnRyeS5iY2RfZGV2aWNlXG4gICAgICB9O1xuICAgICAgZGV2aWNlc0ZvdW5kLnB1c2goZGV2aWNlSW5mbyk7XG4gICAgfSBlbHNlIGlmIChjdXJyZW50RW50cnkuX2l0ZW1zKSB7XG4gICAgICBlbnRyaWVzVG9TZWFyY2ggPSBlbnRyaWVzVG9TZWFyY2guY29uY2F0KGN1cnJlbnRFbnRyeS5faXRlbXMpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGV2aWNlc0ZvdW5kO1xufVxuXG5mdW5jdGlvbiBjbGVhckludGVybmFsQ2FjaGUgKCkge1xuXG4gIC8vIG1lbW9pemVkIGZ1bmN0aW9uc1xuICBjb25zdCBtZW1vaXplZCA9IFtnZXRQYXRoLCBnZXRWZXJzaW9uLCBnZXRBdXRvbWF0aW9uVHJhY2VUZW1wbGF0ZVBhdGgsXG4gICAgICAgICAgICAgICAgICAgIGdldE1heElPU1NES107XG5cbiAgbWVtb2l6ZWQuZm9yRWFjaCgoZikgPT4ge1xuICAgIGlmIChmLmNhY2hlKSB7XG4gICAgICBmLmNhY2hlID0gbmV3IF8ubWVtb2l6ZS5DYWNoZSgpO1xuICAgIH1cbiAgfSk7XG5cblxufVxuXG5leHBvcnQgeyBnZXRQYXRoLCBnZXRWZXJzaW9uLCBnZXRBdXRvbWF0aW9uVHJhY2VUZW1wbGF0ZVBhdGgsIGdldE1heElPU1NESyxcbiAgICAgICAgIGdldEF1dG9tYXRpb25UcmFjZVRlbXBsYXRlUGF0aFdpdGhvdXRSZXRyeSwgZ2V0TWF4SU9TU0RLV2l0aG91dFJldHJ5LFxuICAgICAgICAgZ2V0Q29ubmVjdGVkRGV2aWNlcywgY2xlYXJJbnRlcm5hbENhY2hlIH07XG4iXX0=