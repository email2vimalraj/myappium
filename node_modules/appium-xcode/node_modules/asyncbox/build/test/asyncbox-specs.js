require('source-map-support').install();

/* global describe:true, it:true */
'use strict';

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

var _this = this;

require('mochawait');

var _chai = require('chai');

var _chai2 = _interopRequireDefault(_chai);

var _chaiAsPromised = require('chai-as-promised');

var _chaiAsPromised2 = _interopRequireDefault(_chaiAsPromised);

var _libAsyncbox = require('../lib/asyncbox');

var regIt = it;

_chai2['default'].use(_chaiAsPromised2['default']);
var should = _chai2['default'].should();

describe('sleep', function () {
  it('should work like setTimeout', function callee$1$0() {
    var now;
    return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          now = Date.now();
          context$2$0.next = 3;
          return _regeneratorRuntime.awrap((0, _libAsyncbox.sleep)(20));

        case 3:
          (Date.now() - now).should.be.above(19);

        case 4:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this);
  });
});

describe('retry', function () {
  var okFnCalls = 0;
  var okFn = function okFn(val1, val2) {
    return _regeneratorRuntime.async(function okFn$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          context$2$0.next = 2;
          return _regeneratorRuntime.awrap((0, _libAsyncbox.sleep)(15));

        case 2:
          okFnCalls++;
          return context$2$0.abrupt('return', val1 * val2);

        case 4:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this);
  };
  var badFnCalls = 0;
  var badFn = function badFn() {
    return _regeneratorRuntime.async(function badFn$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          context$2$0.next = 2;
          return _regeneratorRuntime.awrap((0, _libAsyncbox.sleep)(15));

        case 2:
          badFnCalls++;
          throw new Error("bad");

        case 4:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this);
  };
  var eventuallyOkFnCalls = 0;
  var eventuallyOkFn = function eventuallyOkFn(times) {
    return _regeneratorRuntime.async(function eventuallyOkFn$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          context$2$0.next = 2;
          return _regeneratorRuntime.awrap((0, _libAsyncbox.sleep)(15));

        case 2:
          eventuallyOkFnCalls++;

          if (!(eventuallyOkFnCalls < times)) {
            context$2$0.next = 5;
            break;
          }

          throw new Error("not ok yet");

        case 5:
          return context$2$0.abrupt('return', times * times);

        case 6:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this);
  };
  var eventuallyOkNoSleepFn = function eventuallyOkNoSleepFn(times) {
    return _regeneratorRuntime.async(function eventuallyOkNoSleepFn$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          eventuallyOkFnCalls++;

          if (!(eventuallyOkFnCalls < times)) {
            context$2$0.next = 3;
            break;
          }

          throw new Error("not ok yet");

        case 3:
          return context$2$0.abrupt('return', times * times);

        case 4:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this);
  };
  it('should return the result of a passing function', function callee$1$0() {
    var start, res;
    return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          start = Date.now();
          context$2$0.next = 3;
          return _regeneratorRuntime.awrap((0, _libAsyncbox.retry)(3, okFn, 5, 4));

        case 3:
          res = context$2$0.sent;

          res.should.equal(20);
          (Date.now() - start).should.be.above(14);
          okFnCalls.should.equal(1);

        case 7:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this);
  });
  it('should retry a failing function and eventually throw the same err', function callee$1$0() {
    var err, start;
    return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          err = null;
          start = Date.now();
          context$2$0.prev = 2;
          context$2$0.next = 5;
          return _regeneratorRuntime.awrap((0, _libAsyncbox.retry)(3, badFn));

        case 5:
          context$2$0.next = 10;
          break;

        case 7:
          context$2$0.prev = 7;
          context$2$0.t0 = context$2$0['catch'](2);

          err = context$2$0.t0;

        case 10:
          should.exist(err);
          err.message.should.equal('bad');
          badFnCalls.should.equal(3);
          (Date.now() - start).should.be.above(44);

        case 14:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this, [[2, 7]]);
  });
  it('should return the correct value with a function that eventually passes', function callee$1$0() {
    var err, start, res;
    return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          err = null;
          start = Date.now();
          context$2$0.prev = 2;
          context$2$0.next = 5;
          return _regeneratorRuntime.awrap((0, _libAsyncbox.retry)(3, eventuallyOkFn, 4));

        case 5:
          context$2$0.next = 10;
          break;

        case 7:
          context$2$0.prev = 7;
          context$2$0.t0 = context$2$0['catch'](2);

          err = context$2$0.t0;

        case 10:
          should.exist(err);
          err.message.should.equal('not ok yet');
          eventuallyOkFnCalls.should.equal(3);
          (Date.now() - start).should.be.above(35);

          // rerun with ok number of calls
          start = Date.now();
          eventuallyOkFnCalls = 0;
          context$2$0.next = 18;
          return _regeneratorRuntime.awrap((0, _libAsyncbox.retry)(3, eventuallyOkFn, 3));

        case 18:
          res = context$2$0.sent;

          eventuallyOkFnCalls.should.equal(3);
          res.should.equal(9);
          (Date.now() - start).should.be.above(35);

        case 22:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this, [[2, 7]]);
  });
  it('in sleep mode, should return the correct value with a function that eventually passes', function callee$1$0() {
    var err, start, res;
    return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          eventuallyOkFnCalls = 0;
          err = null;
          start = Date.now();
          context$2$0.prev = 3;
          context$2$0.next = 6;
          return _regeneratorRuntime.awrap((0, _libAsyncbox.retryInterval)(3, 15, eventuallyOkNoSleepFn, 4));

        case 6:
          context$2$0.next = 11;
          break;

        case 8:
          context$2$0.prev = 8;
          context$2$0.t0 = context$2$0['catch'](3);

          err = context$2$0.t0;

        case 11:
          should.exist(err);
          err.message.should.equal('not ok yet');
          eventuallyOkFnCalls.should.equal(3);
          (Date.now() - start).should.be.above(30);

          // rerun with ok number of calls
          start = Date.now();
          eventuallyOkFnCalls = 0;
          context$2$0.next = 19;
          return _regeneratorRuntime.awrap((0, _libAsyncbox.retryInterval)(3, 15, eventuallyOkNoSleepFn, 3));

        case 19:
          res = context$2$0.sent;

          eventuallyOkFnCalls.should.equal(3);
          res.should.equal(9);
          (Date.now() - start).should.be.above(30);

        case 23:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this, [[3, 8]]);
  });
});

describe('nodeifyAll', function () {
  var asyncFn = function asyncFn(val) {
    return _regeneratorRuntime.async(function asyncFn$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          context$2$0.next = 2;
          return _regeneratorRuntime.awrap((0, _libAsyncbox.sleep)(15));

        case 2:
          return context$2$0.abrupt('return', val);

        case 3:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this);
  };
  var asyncFn2 = function asyncFn2(val) {
    return _regeneratorRuntime.async(function asyncFn2$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          context$2$0.next = 2;
          return _regeneratorRuntime.awrap((0, _libAsyncbox.sleep)(15));

        case 2:
          return context$2$0.abrupt('return', [val, val + val]);

        case 3:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this);
  };
  var badAsyncFn = function badAsyncFn() {
    return _regeneratorRuntime.async(function badAsyncFn$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          context$2$0.next = 2;
          return _regeneratorRuntime.awrap((0, _libAsyncbox.sleep)(15));

        case 2:
          throw new Error('boo');

        case 3:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this);
  };
  var cbMap = (0, _libAsyncbox.nodeifyAll)({ asyncFn: asyncFn, asyncFn2: asyncFn2, badAsyncFn: badAsyncFn });
  regIt('should turn async functions into nodey things', function (done) {
    var start = Date.now();
    (0, _libAsyncbox.nodeify)(asyncFn('foo'), function (err, val, val2) {
      should.not.exist(err);
      should.not.exist(val2);
      val.should.equal('foo');
      (Date.now() - start).should.be.above(14);
      done();
    });
  });
  regIt('should turn async functions into nodey things via nodeifyAll', function (done) {
    var start = Date.now();
    cbMap.asyncFn('foo', function (err, val, val2) {
      should.not.exist(err);
      should.not.exist(val2);
      val.should.equal('foo');
      (Date.now() - start).should.be.above(14);
      done();
    });
  });
  regIt('should turn async functions into nodey things with mult params', function (done) {
    var start = Date.now();
    (0, _libAsyncbox.nodeify)(asyncFn2('foo'), function (err, val) {
      should.not.exist(err);
      val.should.eql(['foo', 'foofoo']);
      (Date.now() - start).should.be.above(14);
      done();
    });
  });
  regIt('should handle errors correctly', function (done) {
    var start = Date.now();
    (0, _libAsyncbox.nodeify)(badAsyncFn('foo'), function (err, val) {
      should.not.exist(val);
      err.message.should.equal('boo');
      (Date.now() - start).should.be.above(14);
      done();
    });
  });
});

//describe('nodeifyAll', () => {
//let asyncFn = async (val) => {
//await sleep(15);
//return val;
//};
//let asyncFn2 = async (val) => {
//await sleep(15);
//return [val, val + val];
//};
//let badAsyncFn = async () => {
//await sleep(15);
//throw new Error('boo');
//};
//});

describe('parallel', function () {
  var asyncFn = function asyncFn(val) {
    return _regeneratorRuntime.async(function asyncFn$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          context$2$0.next = 2;
          return _regeneratorRuntime.awrap((0, _libAsyncbox.sleep)(50));

        case 2:
          return context$2$0.abrupt('return', val);

        case 3:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this);
  };
  var badAsyncFn = function badAsyncFn() {
    return _regeneratorRuntime.async(function badAsyncFn$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          context$2$0.next = 2;
          return _regeneratorRuntime.awrap((0, _libAsyncbox.sleep)(20));

        case 2:
          throw new Error("boo");

        case 3:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this);
  };
  it('should perform tasks in parallel and return results', function callee$1$0() {
    var vals, promises, start, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, v, res;

    return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          vals = [1, 2, 3];
          promises = [];
          start = Date.now();
          _iteratorNormalCompletion = true;
          _didIteratorError = false;
          _iteratorError = undefined;
          context$2$0.prev = 6;

          for (_iterator = _getIterator(vals); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            v = _step.value;

            promises.push(asyncFn(v));
          }
          context$2$0.next = 14;
          break;

        case 10:
          context$2$0.prev = 10;
          context$2$0.t0 = context$2$0['catch'](6);
          _didIteratorError = true;
          _iteratorError = context$2$0.t0;

        case 14:
          context$2$0.prev = 14;
          context$2$0.prev = 15;

          if (!_iteratorNormalCompletion && _iterator['return']) {
            _iterator['return']();
          }

        case 17:
          context$2$0.prev = 17;

          if (!_didIteratorError) {
            context$2$0.next = 20;
            break;
          }

          throw _iteratorError;

        case 20:
          return context$2$0.finish(17);

        case 21:
          return context$2$0.finish(14);

        case 22:
          context$2$0.next = 24;
          return _regeneratorRuntime.awrap((0, _libAsyncbox.parallel)(promises));

        case 24:
          res = context$2$0.sent;

          (Date.now() - start).should.be.above(49);
          (Date.now() - start).should.be.below(59);
          res.sort().should.eql([1, 2, 3]);

        case 28:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this, [[6, 10, 14, 22], [15,, 17, 21]]);
  });
  it('should error with first response', function callee$1$0() {
    var vals, promises, start, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, v, err, res;

    return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          vals = [1, 2, 3];
          promises = [];
          start = Date.now();
          _iteratorNormalCompletion2 = true;
          _didIteratorError2 = false;
          _iteratorError2 = undefined;
          context$2$0.prev = 6;

          for (_iterator2 = _getIterator(vals); !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            v = _step2.value;

            promises.push(asyncFn(v));
          }
          context$2$0.next = 14;
          break;

        case 10:
          context$2$0.prev = 10;
          context$2$0.t0 = context$2$0['catch'](6);
          _didIteratorError2 = true;
          _iteratorError2 = context$2$0.t0;

        case 14:
          context$2$0.prev = 14;
          context$2$0.prev = 15;

          if (!_iteratorNormalCompletion2 && _iterator2['return']) {
            _iterator2['return']();
          }

        case 17:
          context$2$0.prev = 17;

          if (!_didIteratorError2) {
            context$2$0.next = 20;
            break;
          }

          throw _iteratorError2;

        case 20:
          return context$2$0.finish(17);

        case 21:
          return context$2$0.finish(14);

        case 22:
          promises.push(badAsyncFn());
          err = null;
          res = [];
          context$2$0.prev = 25;
          context$2$0.next = 28;
          return _regeneratorRuntime.awrap((0, _libAsyncbox.parallel)(promises));

        case 28:
          res = context$2$0.sent;
          context$2$0.next = 34;
          break;

        case 31:
          context$2$0.prev = 31;
          context$2$0.t1 = context$2$0['catch'](25);

          err = context$2$0.t1;

        case 34:
          (Date.now() - start).should.be.above(19);
          (Date.now() - start).should.be.below(49);
          should.exist(err);
          res.should.eql([]);

        case 38:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this, [[6, 10, 14, 22], [15,, 17, 21], [25, 31]]);
  });
  it('should not allow parallelizing bad types of things', function callee$1$0() {
    var err;
    return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          err = undefined;
          context$2$0.prev = 1;
          context$2$0.next = 4;
          return _regeneratorRuntime.awrap((0, _libAsyncbox.parallel)('foo'));

        case 4:
          context$2$0.next = 9;
          break;

        case 6:
          context$2$0.prev = 6;
          context$2$0.t0 = context$2$0['catch'](1);

          err = context$2$0.t0;

        case 9:
          should.exist(err);
          context$2$0.prev = 10;
          context$2$0.next = 13;
          return _regeneratorRuntime.awrap((0, _libAsyncbox.parallel)([1]));

        case 13:
          context$2$0.next = 18;
          break;

        case 15:
          context$2$0.prev = 15;
          context$2$0.t1 = context$2$0['catch'](10);

          err = context$2$0.t1;

        case 18:
          should.exist(err);

        case 19:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this, [[1, 6], [10, 15]]);
  });

  describe('waitForCondition', function () {
    it('should wait and succeed', function callee$2$0() {
      var ref, condFn, duration;
      return _regeneratorRuntime.async(function callee$2$0$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
          case 0:
            condFn = function condFn() {
              return Date.now() - ref > 200;
            };

            ref = Date.now();
            context$3$0.next = 4;
            return _regeneratorRuntime.awrap((0, _libAsyncbox.waitForCondition)(condFn, { waitMs: 1000, intervalMs: 10 }));

          case 4:
            duration = Date.now() - ref;

            duration.should.be.above(200);
            duration.should.be.below(250);

          case 7:
          case 'end':
            return context$3$0.stop();
        }
      }, null, _this);
    });
    it('should wait and fail', function callee$2$0() {
      var ref, condFn;
      return _regeneratorRuntime.async(function callee$2$0$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
          case 0:
            condFn = function condFn() {
              return Date.now() - ref > 200;
            };

            ref = Date.now();
            context$3$0.next = 4;
            return _regeneratorRuntime.awrap((0, _libAsyncbox.waitForCondition)(condFn, { waitMs: 100, intervalMs: 10 }).should.be.rejectedWith(/Condition unmet/));

          case 4:
          case 'end':
            return context$3$0.stop();
        }
      }, null, _this);
    });
  });
});

describe('asyncmap', function () {
  var mapper = function mapper(el) {
    return _regeneratorRuntime.async(function mapper$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          context$2$0.next = 2;
          return _regeneratorRuntime.awrap((0, _libAsyncbox.sleep)(10));

        case 2:
          return context$2$0.abrupt('return', el * 2);

        case 3:
        case 'end':
          return context$2$0.stop();
      }
    }, null, this);
  };
  var coll = [1, 2, 3];
  it('should map elements one at a time', function callee$1$0() {
    var start;
    return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          start = Date.now();
          context$2$0.next = 3;
          return _regeneratorRuntime.awrap((0, _libAsyncbox.asyncmap)(coll, mapper, false));

        case 3:
          context$2$0.t0 = [2, 4, 6];
          context$2$0.sent.should.eql(context$2$0.t0);

          (Date.now() - start).should.be.above(30);

        case 6:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this);
  });
  it('should map elements in parallel', function callee$1$0() {
    var start;
    return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          start = Date.now();
          context$2$0.next = 3;
          return _regeneratorRuntime.awrap((0, _libAsyncbox.asyncmap)(coll, mapper));

        case 3:
          context$2$0.t0 = [2, 4, 6];
          context$2$0.sent.should.eql(context$2$0.t0);

          (Date.now() - start).should.be.below(20);

        case 6:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this);
  });
  it('should handle an empty array', function callee$1$0() {
    return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          context$2$0.next = 2;
          return _regeneratorRuntime.awrap((0, _libAsyncbox.asyncmap)([], mapper, false));

        case 2:
          context$2$0.t0 = [];
          context$2$0.sent.should.eql(context$2$0.t0);

        case 4:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this);
  });
  it('should handle an empty array in parallel', function callee$1$0() {
    return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          context$2$0.next = 2;
          return _regeneratorRuntime.awrap((0, _libAsyncbox.asyncmap)([], mapper));

        case 2:
          context$2$0.t0 = [];
          context$2$0.sent.should.eql(context$2$0.t0);

        case 4:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this);
  });
});

describe('asyncfilter', function () {
  var filter = function filter(el) {
    return _regeneratorRuntime.async(function filter$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          context$2$0.next = 2;
          return _regeneratorRuntime.awrap((0, _libAsyncbox.sleep)(5));

        case 2:
          return context$2$0.abrupt('return', el % 2 === 0);

        case 3:
        case 'end':
          return context$2$0.stop();
      }
    }, null, this);
  };
  var coll = [1, 2, 3, 4, 5];
  it('should filter elements one at a time', function callee$1$0() {
    var start;
    return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          start = Date.now();
          context$2$0.next = 3;
          return _regeneratorRuntime.awrap((0, _libAsyncbox.asyncfilter)(coll, filter, false));

        case 3:
          context$2$0.t0 = [2, 4];
          context$2$0.sent.should.eql(context$2$0.t0);

          (Date.now() - start).should.be.above(19);

        case 6:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this);
  });
  it('should filter elements in parallel', function callee$1$0() {
    var start;
    return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          start = Date.now();
          context$2$0.next = 3;
          return _regeneratorRuntime.awrap((0, _libAsyncbox.asyncfilter)(coll, filter));

        case 3:
          context$2$0.t0 = [2, 4];
          context$2$0.sent.should.eql(context$2$0.t0);

          (Date.now() - start).should.be.below(9);

        case 6:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this);
  });
  it('should handle an empty array', function callee$1$0() {
    var start;
    return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          start = Date.now();
          context$2$0.next = 3;
          return _regeneratorRuntime.awrap((0, _libAsyncbox.asyncfilter)([], filter, false));

        case 3:
          context$2$0.t0 = [];
          context$2$0.sent.should.eql(context$2$0.t0);

          (Date.now() - start).should.be.below(9);

        case 6:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this);
  });
  it('should handle an empty array in parallel', function callee$1$0() {
    var start;
    return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          start = Date.now();
          context$2$0.next = 3;
          return _regeneratorRuntime.awrap((0, _libAsyncbox.asyncfilter)([], filter));

        case 3:
          context$2$0.t0 = [];
          context$2$0.sent.should.eql(context$2$0.t0);

          (Date.now() - start).should.be.below(9);

        case 6:
        case 'end':
          return context$2$0.stop();
      }
    }, null, _this);
  });
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInRlc3QvYXN5bmNib3gtc3BlY3MuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztRQUlPLFdBQVc7O29CQUNELE1BQU07Ozs7OEJBQ0ksa0JBQWtCOzs7OzJCQUVxQixpQkFBaUI7O0FBTG5GLElBQUksS0FBSyxHQUFHLEVBQUUsQ0FBQzs7QUFPZixrQkFBSyxHQUFHLDZCQUFnQixDQUFDO0FBQ3pCLElBQUksTUFBTSxHQUFHLGtCQUFLLE1BQU0sRUFBRSxDQUFDOztBQUUzQixRQUFRLENBQUMsT0FBTyxFQUFFLFlBQU07QUFDdEIsSUFBRSxDQUFDLDZCQUE2QixFQUFFO1FBQzVCLEdBQUc7Ozs7QUFBSCxhQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsRUFBRTs7MkNBQ2QsaUJBVEQsS0FBSyxFQVNFLEVBQUUsQ0FBQzs7O0FBQ2YsV0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLEdBQUcsR0FBRyxDQUFBLENBQUUsTUFBTSxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUM7Ozs7Ozs7R0FDeEMsQ0FBQyxDQUFDO0NBQ0osQ0FBQyxDQUFDOztBQUVILFFBQVEsQ0FBQyxPQUFPLEVBQUUsWUFBTTtBQUN0QixNQUFJLFNBQVMsR0FBRyxDQUFDLENBQUM7QUFDbEIsTUFBSSxJQUFJLEdBQUcsU0FBUCxJQUFJLENBQVUsSUFBSSxFQUFFLElBQUk7Ozs7OzJDQUNwQixpQkFqQkQsS0FBSyxFQWlCRSxFQUFFLENBQUM7OztBQUNmLG1CQUFTLEVBQUUsQ0FBQzs4Q0FDTCxJQUFJLEdBQUcsSUFBSTs7Ozs7OztHQUNuQixDQUFDO0FBQ0YsTUFBSSxVQUFVLEdBQUcsQ0FBQyxDQUFDO0FBQ25CLE1BQUksS0FBSyxHQUFHLFNBQVIsS0FBSzs7Ozs7MkNBQ0QsaUJBdkJELEtBQUssRUF1QkUsRUFBRSxDQUFDOzs7QUFDZixvQkFBVSxFQUFFLENBQUM7Z0JBQ1AsSUFBSSxLQUFLLENBQUMsS0FBSyxDQUFDOzs7Ozs7O0dBQ3ZCLENB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cy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHRyYW5zcGlsZTptb2NoYVxuXG4vKiBnbG9iYWwgZGVzY3JpYmU6dHJ1ZSwgaXQ6dHJ1ZSAqL1xubGV0IHJlZ0l0ID0gaXQ7XG5pbXBvcnQgJ21vY2hhd2FpdCc7XG5pbXBvcnQgY2hhaSBmcm9tICdjaGFpJztcbmltcG9ydCBjaGFpQXNQcm9taXNlZCBmcm9tICdjaGFpLWFzLXByb21pc2VkJztcbmltcG9ydCB7IHNsZWVwLCByZXRyeSwgcmV0cnlJbnRlcnZhbCwgbm9kZWlmeSwgbm9kZWlmeUFsbCxcbiAgICAgICAgIHBhcmFsbGVsLCBhc3luY21hcCwgYXN5bmNmaWx0ZXIsIHdhaXRGb3JDb25kaXRpb24gfSBmcm9tICcuLi9saWIvYXN5bmNib3gnO1xuXG5jaGFpLnVzZShjaGFpQXNQcm9taXNlZCk7XG5sZXQgc2hvdWxkID0gY2hhaS5zaG91bGQoKTtcblxuZGVzY3JpYmUoJ3NsZWVwJywgKCkgPT4ge1xuICBpdCgnc2hvdWxkIHdvcmsgbGlrZSBzZXRUaW1lb3V0JywgYXN5bmMgKCkgPT4ge1xuICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuICAgIGF3YWl0IHNsZWVwKDIwKTtcbiAgICAoRGF0ZS5ub3coKSAtIG5vdykuc2hvdWxkLmJlLmFib3ZlKDE5KTtcbiAgfSk7XG59KTtcblxuZGVzY3JpYmUoJ3JldHJ5JywgKCkgPT4ge1xuICBsZXQgb2tGbkNhbGxzID0gMDtcbiAgbGV0IG9rRm4gPSBhc3luYyAodmFsMSwgdmFsMikgPT4ge1xuICAgIGF3YWl0IHNsZWVwKDE1KTtcbiAgICBva0ZuQ2FsbHMrKztcbiAgICByZXR1cm4gdmFsMSAqIHZhbDI7XG4gIH07XG4gIGxldCBiYWRGbkNhbGxzID0gMDtcbiAgbGV0IGJhZEZuID0gYXN5bmMgKCkgPT4ge1xuICAgIGF3YWl0IHNsZWVwKDE1KTtcbiAgICBiYWRGbkNhbGxzKys7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYmFkXCIpO1xuICB9O1xuICBsZXQgZXZlbnR1YWxseU9rRm5DYWxscyA9IDA7XG4gIGxldCBldmVudHVhbGx5T2tGbiA9IGFzeW5jICh0aW1lcykgPT4ge1xuICAgIGF3YWl0IHNsZWVwKDE1KTtcbiAgICBldmVudHVhbGx5T2tGbkNhbGxzKys7XG4gICAgaWYgKGV2ZW50dWFsbHlPa0ZuQ2FsbHMgPCB0aW1lcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm90IG9rIHlldFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRpbWVzICogdGltZXM7XG4gIH07XG4gIGxldCBldmVudHVhbGx5T2tOb1NsZWVwRm4gPSBhc3luYyAodGltZXMpID0+IHtcbiAgICBldmVudHVhbGx5T2tGbkNhbGxzKys7XG4gICAgaWYgKGV2ZW50dWFsbHlPa0ZuQ2FsbHMgPCB0aW1lcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm90IG9rIHlldFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRpbWVzICogdGltZXM7XG4gIH07XG4gIGl0KCdzaG91bGQgcmV0dXJuIHRoZSByZXN1bHQgb2YgYSBwYXNzaW5nIGZ1bmN0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgIGxldCBzdGFydCA9IERhdGUubm93KCk7XG4gICAgbGV0IHJlcyA9IGF3YWl0IHJldHJ5KDMsIG9rRm4sIDUsIDQpO1xuICAgIHJlcy5zaG91bGQuZXF1YWwoMjApO1xuICAgIChEYXRlLm5vdygpIC0gc3RhcnQpLnNob3VsZC5iZS5hYm92ZSgxNCk7XG4gICAgb2tGbkNhbGxzLnNob3VsZC5lcXVhbCgxKTtcbiAgfSk7XG4gIGl0KCdzaG91bGQgcmV0cnkgYSBmYWlsaW5nIGZ1bmN0aW9uIGFuZCBldmVudHVhbGx5IHRocm93IHRoZSBzYW1lIGVycicsIGFzeW5jICgpID0+IHtcbiAgICBsZXQgZXJyID0gbnVsbDtcbiAgICBsZXQgc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCByZXRyeSgzLCBiYWRGbik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXJyID0gZTtcbiAgICB9XG4gICAgc2hvdWxkLmV4aXN0KGVycik7XG4gICAgZXJyLm1lc3NhZ2Uuc2hvdWxkLmVxdWFsKCdiYWQnKTtcbiAgICBiYWRGbkNhbGxzLnNob3VsZC5lcXVhbCgzKTtcbiAgICAoRGF0ZS5ub3coKSAtIHN0YXJ0KS5zaG91bGQuYmUuYWJvdmUoNDQpO1xuICB9KTtcbiAgaXQoJ3Nob3VsZCByZXR1cm4gdGhlIGNvcnJlY3QgdmFsdWUgd2l0aCBhIGZ1bmN0aW9uIHRoYXQgZXZlbnR1YWxseSBwYXNzZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgbGV0IGVyciA9IG51bGw7XG4gICAgbGV0IHN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgcmV0cnkoMywgZXZlbnR1YWxseU9rRm4sIDQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGVyciA9IGU7XG4gICAgfVxuICAgIHNob3VsZC5leGlzdChlcnIpO1xuICAgIGVyci5tZXNzYWdlLnNob3VsZC5lcXVhbCgnbm90IG9rIHlldCcpO1xuICAgIGV2ZW50dWFsbHlPa0ZuQ2FsbHMuc2hvdWxkLmVxdWFsKDMpO1xuICAgIChEYXRlLm5vdygpIC0gc3RhcnQpLnNob3VsZC5iZS5hYm92ZSgzNSk7XG5cbiAgICAvLyByZXJ1biB3aXRoIG9rIG51bWJlciBvZiBjYWxsc1xuICAgIHN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICBldmVudHVhbGx5T2tGbkNhbGxzID0gMDtcbiAgICBsZXQgcmVzID0gYXdhaXQgcmV0cnkoMywgZXZlbnR1YWxseU9rRm4sIDMpO1xuICAgIGV2ZW50dWFsbHlPa0ZuQ2FsbHMuc2hvdWxkLmVxdWFsKDMpO1xuICAgIHJlcy5zaG91bGQuZXF1YWwoOSk7XG4gICAgKERhdGUubm93KCkgLSBzdGFydCkuc2hvdWxkLmJlLmFib3ZlKDM1KTtcbiAgfSk7XG4gIGl0KCdpbiBzbGVlcCBtb2RlLCBzaG91bGQgcmV0dXJuIHRoZSBjb3JyZWN0IHZhbHVlIHdpdGggYSBmdW5jdGlvbiB0aGF0IGV2ZW50dWFsbHkgcGFzc2VzJywgYXN5bmMgKCkgPT4ge1xuICAgIGV2ZW50dWFsbHlPa0ZuQ2FsbHMgPSAwO1xuICAgIGxldCBlcnIgPSBudWxsO1xuICAgIGxldCBzdGFydCA9IERhdGUubm93KCk7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHJldHJ5SW50ZXJ2YWwoMywgMTUsIGV2ZW50dWFsbHlPa05vU2xlZXBGbiwgNCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXJyID0gZTtcbiAgICB9XG4gICAgc2hvdWxkLmV4aXN0KGVycik7XG4gICAgZXJyLm1lc3NhZ2Uuc2hvdWxkLmVxdWFsKCdub3Qgb2sgeWV0Jyk7XG4gICAgZXZlbnR1YWxseU9rRm5DYWxscy5zaG91bGQuZXF1YWwoMyk7XG4gICAgKERhdGUubm93KCkgLSBzdGFydCkuc2hvdWxkLmJlLmFib3ZlKDMwKTtcblxuICAgIC8vIHJlcnVuIHdpdGggb2sgbnVtYmVyIG9mIGNhbGxzXG4gICAgc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgIGV2ZW50dWFsbHlPa0ZuQ2FsbHMgPSAwO1xuICAgIGxldCByZXMgPSBhd2FpdCByZXRyeUludGVydmFsKDMsIDE1LCBldmVudHVhbGx5T2tOb1NsZWVwRm4sIDMpO1xuICAgIGV2ZW50dWFsbHlPa0ZuQ2FsbHMuc2hvdWxkLmVxdWFsKDMpO1xuICAgIHJlcy5zaG91bGQuZXF1YWwoOSk7XG4gICAgKERhdGUubm93KCkgLSBzdGFydCkuc2hvdWxkLmJlLmFib3ZlKDMwKTtcbiAgfSk7XG59KTtcblxuZGVzY3JpYmUoJ25vZGVpZnlBbGwnLCAoKSA9PiB7XG4gIGxldCBhc3luY0ZuID0gYXN5bmMgKHZhbCkgPT4ge1xuICAgIGF3YWl0IHNsZWVwKDE1KTtcbiAgICByZXR1cm4gdmFsO1xuICB9O1xuICBsZXQgYXN5bmNGbjIgPSBhc3luYyAodmFsKSA9PiB7XG4gICAgYXdhaXQgc2xlZXAoMTUpO1xuICAgIHJldHVybiBbdmFsLCB2YWwgKyB2YWxdO1xuICB9O1xuICBsZXQgYmFkQXN5bmNGbiA9IGFzeW5jICgpID0+IHtcbiAgICBhd2FpdCBzbGVlcCgxNSk7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdib28nKTtcbiAgfTtcbiAgbGV0IGNiTWFwID0gbm9kZWlmeUFsbCh7YXN5bmNGbiwgYXN5bmNGbjIsIGJhZEFzeW5jRm59KTtcbiAgcmVnSXQoJ3Nob3VsZCB0dXJuIGFzeW5jIGZ1bmN0aW9ucyBpbnRvIG5vZGV5IHRoaW5ncycsIGRvbmUgPT4ge1xuICAgIGxldCBzdGFydCA9IERhdGUubm93KCk7XG4gICAgbm9kZWlmeShhc3luY0ZuKCdmb28nKSwgKGVyciwgdmFsLCB2YWwyKSA9PiB7XG4gICAgICBzaG91bGQubm90LmV4aXN0KGVycik7XG4gICAgICBzaG91bGQubm90LmV4aXN0KHZhbDIpO1xuICAgICAgdmFsLnNob3VsZC5lcXVhbCgnZm9vJyk7XG4gICAgICAoRGF0ZS5ub3coKSAtIHN0YXJ0KS5zaG91bGQuYmUuYWJvdmUoMTQpO1xuICAgICAgZG9uZSgpO1xuICAgIH0pO1xuICB9KTtcbiAgcmVnSXQoJ3Nob3VsZCB0dXJuIGFzeW5jIGZ1bmN0aW9ucyBpbnRvIG5vZGV5IHRoaW5ncyB2aWEgbm9kZWlmeUFsbCcsIGRvbmUgPT4ge1xuICAgIGxldCBzdGFydCA9IERhdGUubm93KCk7XG4gICAgY2JNYXAuYXN5bmNGbignZm9vJywgKGVyciwgdmFsLCB2YWwyKSA9PiB7XG4gICAgICBzaG91bGQubm90LmV4aXN0KGVycik7XG4gICAgICBzaG91bGQubm90LmV4aXN0KHZhbDIpO1xuICAgICAgdmFsLnNob3VsZC5lcXVhbCgnZm9vJyk7XG4gICAgICAoRGF0ZS5ub3coKSAtIHN0YXJ0KS5zaG91bGQuYmUuYWJvdmUoMTQpO1xuICAgICAgZG9uZSgpO1xuICAgIH0pO1xuICB9KTtcbiAgcmVnSXQoJ3Nob3VsZCB0dXJuIGFzeW5jIGZ1bmN0aW9ucyBpbnRvIG5vZGV5IHRoaW5ncyB3aXRoIG11bHQgcGFyYW1zJywgZG9uZSA9PiB7XG4gICAgbGV0IHN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICBub2RlaWZ5KGFzeW5jRm4yKCdmb28nKSwgKGVyciwgdmFsKSA9PiB7XG4gICAgICBzaG91bGQubm90LmV4aXN0KGVycik7XG4gICAgICB2YWwuc2hvdWxkLmVxbChbJ2ZvbycsICdmb29mb28nXSk7XG4gICAgICAoRGF0ZS5ub3coKSAtIHN0YXJ0KS5zaG91bGQuYmUuYWJvdmUoMTQpO1xuICAgICAgZG9uZSgpO1xuICAgIH0pO1xuICB9KTtcbiAgcmVnSXQoJ3Nob3VsZCBoYW5kbGUgZXJyb3JzIGNvcnJlY3RseScsIGRvbmUgPT4ge1xuICAgIGxldCBzdGFydCA9IERhdGUubm93KCk7XG4gICAgbm9kZWlmeShiYWRBc3luY0ZuKCdmb28nKSwgKGVyciwgdmFsKSA9PiB7XG4gICAgICBzaG91bGQubm90LmV4aXN0KHZhbCk7XG4gICAgICBlcnIubWVzc2FnZS5zaG91bGQuZXF1YWwoJ2JvbycpO1xuICAgICAgKERhdGUubm93KCkgLSBzdGFydCkuc2hvdWxkLmJlLmFib3ZlKDE0KTtcbiAgICAgIGRvbmUoKTtcbiAgICB9KTtcbiAgfSk7XG59KTtcblxuLy9kZXNjcmliZSgnbm9kZWlmeUFsbCcsICgpID0+IHtcbiAgLy9sZXQgYXN5bmNGbiA9IGFzeW5jICh2YWwpID0+IHtcbiAgICAvL2F3YWl0IHNsZWVwKDE1KTtcbiAgICAvL3JldHVybiB2YWw7XG4gIC8vfTtcbiAgLy9sZXQgYXN5bmNGbjIgPSBhc3luYyAodmFsKSA9PiB7XG4gICAgLy9hd2FpdCBzbGVlcCgxNSk7XG4gICAgLy9yZXR1cm4gW3ZhbCwgdmFsICsgdmFsXTtcbiAgLy99O1xuICAvL2xldCBiYWRBc3luY0ZuID0gYXN5bmMgKCkgPT4ge1xuICAgIC8vYXdhaXQgc2xlZXAoMTUpO1xuICAgIC8vdGhyb3cgbmV3IEVycm9yKCdib28nKTtcbiAgLy99O1xuLy99KTtcblxuZGVzY3JpYmUoJ3BhcmFsbGVsJywgKCkgPT4ge1xuICBsZXQgYXN5bmNGbiA9IGFzeW5jICh2YWwpID0+IHtcbiAgICBhd2FpdCBzbGVlcCg1MCk7XG4gICAgcmV0dXJuIHZhbDtcbiAgfTtcbiAgbGV0IGJhZEFzeW5jRm4gPSBhc3luYyAoKSA9PiB7XG4gICAgYXdhaXQgc2xlZXAoMjApO1xuICAgIHRocm93IG5ldyBFcnJvcihcImJvb1wiKTtcbiAgfTtcbiAgaXQoJ3Nob3VsZCBwZXJmb3JtIHRhc2tzIGluIHBhcmFsbGVsIGFuZCByZXR1cm4gcmVzdWx0cycsIGFzeW5jICgpID0+IHtcbiAgICBsZXQgdmFscyA9IFsxLCAyLCAzXTtcbiAgICBsZXQgcHJvbWlzZXMgPSBbXTtcbiAgICBsZXQgc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgIGZvciAobGV0IHYgb2YgdmFscykge1xuICAgICAgcHJvbWlzZXMucHVzaChhc3luY0ZuKHYpKTtcbiAgICB9XG4gICAgbGV0IHJlcyA9IGF3YWl0IHBhcmFsbGVsKHByb21pc2VzKTtcbiAgICAoRGF0ZS5ub3coKSAtIHN0YXJ0KS5zaG91bGQuYmUuYWJvdmUoNDkpO1xuICAgIChEYXRlLm5vdygpIC0gc3RhcnQpLnNob3VsZC5iZS5iZWxvdyg1OSk7XG4gICAgcmVzLnNvcnQoKS5zaG91bGQuZXFsKFsxLCAyLCAzXSk7XG4gIH0pO1xuICBpdCgnc2hvdWxkIGVycm9yIHdpdGggZmlyc3QgcmVzcG9uc2UnLCBhc3luYyAoKSA9PiB7XG4gICAgbGV0IHZhbHMgPSBbMSwgMiwgM107XG4gICAgbGV0IHByb21pc2VzID0gW107XG4gICAgbGV0IHN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICBmb3IgKGxldCB2IG9mIHZhbHMpIHtcbiAgICAgIHByb21pc2VzLnB1c2goYXN5bmNGbih2KSk7XG4gICAgfVxuICAgIHByb21pc2VzLnB1c2goYmFkQXN5bmNGbigpKTtcbiAgICBsZXQgZXJyID0gbnVsbDtcbiAgICBsZXQgcmVzID0gW107XG4gICAgdHJ5IHtcbiAgICAgIHJlcyA9IGF3YWl0IHBhcmFsbGVsKHByb21pc2VzKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlcnIgPSBlO1xuICAgIH1cbiAgICAoRGF0ZS5ub3coKSAtIHN0YXJ0KS5zaG91bGQuYmUuYWJvdmUoMTkpO1xuICAgIChEYXRlLm5vdygpIC0gc3RhcnQpLnNob3VsZC5iZS5iZWxvdyg0OSk7XG4gICAgc2hvdWxkLmV4aXN0KGVycik7XG4gICAgcmVzLnNob3VsZC5lcWwoW10pO1xuICB9KTtcbiAgaXQoJ3Nob3VsZCBub3QgYWxsb3cgcGFyYWxsZWxpemluZyBiYWQgdHlwZXMgb2YgdGhpbmdzJywgYXN5bmMgKCkgPT4ge1xuICAgIGxldCBlcnI7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHBhcmFsbGVsKCdmb28nKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlcnIgPSBlO1xuICAgIH1cbiAgICBzaG91bGQuZXhpc3QoZXJyKTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgcGFyYWxsZWwoWzFdKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlcnIgPSBlO1xuICAgIH1cbiAgICBzaG91bGQuZXhpc3QoZXJyKTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ3dhaXRGb3JDb25kaXRpb24nLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCB3YWl0IGFuZCBzdWNjZWVkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbGV0IHJlZiA9IERhdGUubm93KCk7XG4gICAgICBmdW5jdGlvbiBjb25kRm4oKSB7XG4gICAgICAgIHJldHVybiBEYXRlLm5vdygpIC0gcmVmID4gMjAwO1xuICAgICAgfVxuICAgICAgYXdhaXQgd2FpdEZvckNvbmRpdGlvbihjb25kRm4sIHt3YWl0TXM6IDEwMDAsIGludGVydmFsTXM6IDEwfSk7XG4gICAgICBsZXQgZHVyYXRpb24gPSBEYXRlLm5vdygpIC0gcmVmO1xuICAgICAgZHVyYXRpb24uc2hvdWxkLmJlLmFib3ZlKDIwMCk7XG4gICAgICBkdXJhdGlvbi5zaG91bGQuYmUuYmVsb3coMjUwKTtcbiAgICB9KTtcbiAgICBpdCgnc2hvdWxkIHdhaXQgYW5kIGZhaWwnLCBhc3luYyAoKSA9PiB7XG4gICAgICBsZXQgcmVmID0gRGF0ZS5ub3coKTtcbiAgICAgIGZ1bmN0aW9uIGNvbmRGbigpIHtcbiAgICAgICAgcmV0dXJuIERhdGUubm93KCkgLSByZWYgPiAyMDA7XG4gICAgICB9XG4gICAgICBhd2FpdCAod2FpdEZvckNvbmRpdGlvbihjb25kRm4sIHt3YWl0TXM6IDEwMCwgaW50ZXJ2YWxNczogMTB9KSlcbiAgICAgICAgLnNob3VsZC5iZS5yZWplY3RlZFdpdGgoL0NvbmRpdGlvbiB1bm1ldC8pO1xuICAgIH0pO1xuICB9KTtcbn0pO1xuXG5kZXNjcmliZSgnYXN5bmNtYXAnLCAoKSA9PiB7XG4gIGNvbnN0IG1hcHBlciA9IGFzeW5jIGZ1bmN0aW9uIChlbCkge1xuICAgIGF3YWl0IHNsZWVwKDEwKTtcbiAgICByZXR1cm4gZWwgKiAyO1xuICB9O1xuICBjb25zdCBjb2xsID0gWzEsIDIsIDNdO1xuICBpdCgnc2hvdWxkIG1hcCBlbGVtZW50cyBvbmUgYXQgYSB0aW1lJywgYXN5bmMgKCkgPT4ge1xuICAgIGxldCBzdGFydCA9IERhdGUubm93KCk7XG4gICAgKGF3YWl0IGFzeW5jbWFwKGNvbGwsIG1hcHBlciwgZmFsc2UpKS5zaG91bGQuZXFsKFsyLCA0LCA2XSk7XG4gICAgKERhdGUubm93KCkgLSBzdGFydCkuc2hvdWxkLmJlLmFib3ZlKDMwKTtcbiAgfSk7XG4gIGl0KCdzaG91bGQgbWFwIGVsZW1lbnRzIGluIHBhcmFsbGVsJywgYXN5bmMgKCkgPT4ge1xuICAgIGxldCBzdGFydCA9IERhdGUubm93KCk7XG4gICAgKGF3YWl0IGFzeW5jbWFwKGNvbGwsIG1hcHBlcikpLnNob3VsZC5lcWwoWzIsIDQsIDZdKTtcbiAgICAoRGF0ZS5ub3coKSAtIHN0YXJ0KS5zaG91bGQuYmUuYmVsb3coMjApO1xuICB9KTtcbiAgaXQoJ3Nob3VsZCBoYW5kbGUgYW4gZW1wdHkgYXJyYXknLCBhc3luYyAoKSA9PiB7XG4gICAgKGF3YWl0IGFzeW5jbWFwKFtdLCBtYXBwZXIsIGZhbHNlKSkuc2hvdWxkLmVxbChbXSk7XG4gIH0pO1xuICBpdCgnc2hvdWxkIGhhbmRsZSBhbiBlbXB0eSBhcnJheSBpbiBwYXJhbGxlbCcsIGFzeW5jICgpID0+IHtcbiAgICAoYXdhaXQgYXN5bmNtYXAoW10sIG1hcHBlcikpLnNob3VsZC5lcWwoW10pO1xuICB9KTtcbn0pO1xuXG5kZXNjcmliZSgnYXN5bmNmaWx0ZXInLCAoKSA9PiB7XG4gIGNvbnN0IGZpbHRlciA9IGFzeW5jIGZ1bmN0aW9uIChlbCkge1xuICAgIGF3YWl0IHNsZWVwKDUpO1xuICAgIHJldHVybiBlbCAlIDIgPT09IDA7XG4gIH07XG4gIGNvbnN0IGNvbGwgPSBbMSwgMiwgMywgNCwgNV07XG4gIGl0KCdzaG91bGQgZmlsdGVyIGVsZW1lbnRzIG9uZSBhdCBhIHRpbWUnLCBhc3luYyAoKSA9PiB7XG4gICAgbGV0IHN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICAoYXdhaXQgYXN5bmNmaWx0ZXIoY29sbCwgZmlsdGVyLCBmYWxzZSkpLnNob3VsZC5lcWwoWzIsIDRdKTtcbiAgICAoRGF0ZS5ub3coKSAtIHN0YXJ0KS5zaG91bGQuYmUuYWJvdmUoMTkpO1xuICB9KTtcbiAgaXQoJ3Nob3VsZCBmaWx0ZXIgZWxlbWVudHMgaW4gcGFyYWxsZWwnLCBhc3luYyAoKSA9PiB7XG4gICAgbGV0IHN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICAoYXdhaXQgYXN5bmNmaWx0ZXIoY29sbCwgZmlsdGVyKSkuc2hvdWxkLmVxbChbMiwgNF0pO1xuICAgIChEYXRlLm5vdygpIC0gc3RhcnQpLnNob3VsZC5iZS5iZWxvdyg5KTtcbiAgfSk7XG4gIGl0KCdzaG91bGQgaGFuZGxlIGFuIGVtcHR5IGFycmF5JywgYXN5bmMgKCkgPT4ge1xuICAgIGxldCBzdGFydCA9IERhdGUubm93KCk7XG4gICAgKGF3YWl0IGFzeW5jZmlsdGVyKFtdLCBmaWx0ZXIsIGZhbHNlKSkuc2hvdWxkLmVxbChbXSk7XG4gICAgKERhdGUubm93KCkgLSBzdGFydCkuc2hvdWxkLmJlLmJlbG93KDkpO1xuICB9KTtcbiAgaXQoJ3Nob3VsZCBoYW5kbGUgYW4gZW1wdHkgYXJyYXkgaW4gcGFyYWxsZWwnLCBhc3luYyAoKSA9PiB7XG4gICAgbGV0IHN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICAoYXdhaXQgYXN5bmNmaWx0ZXIoW10sIGZpbHRlcikpLnNob3VsZC5lcWwoW10pO1xuICAgIChEYXRlLm5vdygpIC0gc3RhcnQpLnNob3VsZC5iZS5iZWxvdyg5KTtcbiAgfSk7XG59KTtcbiJdfQ==